 <!DOCTYPE html>
<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><title>AI Tutorial | Artificial Intelligence Tutorial - Javatpoint</title><link href="https://static.javatpoint.com/images/favicon2.png" rel="SHORTCUT ICON"/>
<link href="https://static.javatpoint.com/link.css" rel="stylesheet" type="text/css"/><link href="https://clients1.google.com" rel="dns-prefetch"/><link href="https://static.javatpoint.com" rel="dns-prefetch"/><link href="https://googleads.g.doubleclick.net" rel="dns-prefetch"/><link href="https://www.google.com" rel="dns-prefetch"/><link href="https://feedify.net" rel="dns-prefetch"/><meta content="#4CAF50" name="theme-color"><meta content="AI Tutorial | Artificial Intelligence Tutorial - Javatpoint" property="og:title"/><meta content="AI Tutorial | Artificial Intelligence Tutorial with AI, Artificial Intelligence, Tutorial, Introduction, History of Artificial Intelligence, AI Overview, Application of AI, Types of AI, What is AI, etc." property="og:description"/>
<meta content="ai, artificial intelligence, tutorial, introduction, history of artificial intelligence, ai overview, application of ai, types of ai, what is ai" name="keywords"/><meta content="AI Tutorial | Artificial Intelligence Tutorial with AI, Artificial Intelligence, Tutorial, Introduction, History of Artificial Intelligence, AI Overview, Application of AI, Types of AI, What is AI, etc." name="description"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black" name="apple-mobile-web-app-status-bar-style"/><link href="https://www.javatpoint.com/artificial-intelligence-tutorial" rel="canonical">
<meta content="en_US" property="og:locale"><meta content="article" property="og:type"><meta content="AI Tutorial | Artificial Intelligence Tutorial - Javatpoint" name="twitter:title" property="og:title"><meta content="AI Tutorial | Artificial Intelligence Tutorial with AI, Artificial Intelligence, Tutorial, Introduction, History of Artificial Intelligence, AI Overview, Application of AI, Types of AI, What is AI, etc." name="twitter:description" property="og:description"/><meta content="https://www.javatpoint.com/artificial-intelligence-tutorial" property="og:url"/><meta content="www.javatpoint.com" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="@pagejavatpoint" name="twitter:site"/><meta content="www.javatpoint.com" name="twitter:domain"/><meta content="@pagejavatpoint" name="twitter:creator"/>
<link href="https://www.javatpoint.com/manifest.json" rel="manifest"/>
<script data-cfasync="false" type="text/javascript">(function(w, d) { var s = d.createElement('script'); s.src = '//delivery.adrecover.com/37784/adRecover.js?ts=1543562646174'; s.type = 'text/javascript'; s.async = true; (d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0]).appendChild(s); })(window, document);</script>
<script data-cfasync="false" type="text/javascript">(function(w, d) { var s = d.createElement('script'); s.src = '//cdn.adpushup.com/37780/adpushup.js'; s.type = 'text/javascript'; s.async = true; (d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0]).appendChild(s); })(window, document);</script>
</meta></meta></meta></link></meta></head>

<body>
<h1 class="h1">Artificial Intelligence Tutorial</h1>
<img alt="Artificial Intelligence Tutorial | AI Tutorial" src="https://static.javatpoint.com/tutorial/ai/images/ai-tutorial.png" style="float:right;padding-left:15px"/>
<p>The Artificial Intelligence tutorial provides an introduction to AI which will help you to understand the concepts behind <a href="https://www.tutorialandexample.com/artificial-intelligence-tutorial/" target="_blank">Artificial Intelligence</a>. In this tutorial, we have also discussed various popular topics such as History of AI, applications of AI, deep learning, machine learning, natural language processing, Reinforcement learning, Q-learning, Intelligent agents, Various search algorithms, etc.</p>
<p>Our AI tutorial is prepared from an elementary level so you can easily understand the complete tutorial from basic concepts to the high-level concepts.</p>
<h2 class="h2">Prerequisite</h2>
<p>Before learning about Artificial Intelligence, you must have the fundamental knowledge of following so that you can understand the concepts easily:</p>
<ul class="points">
<li>Any computer language such as C, C++, Java, Python, etc.(knowledge of Python will be an advantage)</li>
<li>Knowledge of essential Mathematics such as derivatives, probability theory, etc.</li>
</ul>
<h2 class="h2">Audience</h2>
<p>Our AI tutorial is designed specifically for beginners and also included some high-level concepts for professionals. </p>
<h2 class="h2">Problems</h2>
<p>We assure you that you will not find any difficulty while learning our AI tutorial. But if there any mistake, kindly post the problem in the contact form. </p>
<h1 class="h1">Artificial Intelligence</h1>
<p>In today's world, technology is growing very fast, and we are getting in touch with different new technologies day by day.</p>
<p>Here, one of the booming technologies of computer science is Artificial Intelligence which is ready to create a new revolution in the world by making intelligent machines.The Artificial Intelligence is now all around us. It is currently working with a variety of subfields, ranging from general to specific, such as self-driving cars, playing chess, proving theorems, playing music, Painting, etc.</p>
<p>AI is one of the fascinating and universal fields of Computer science which has a great scope in future. AI holds a tendency to cause a machine to work as a human.</p>
<h2 class="h2">What is Artificial Intelligence?</h2>
<img alt="Introduction to AI" src="https://static.javatpoint.com/tutorial/ai/images/introduction-to-artificial-intelligence.png"/>
<br/>
<p>Artificial Intelligence is composed of two words <strong>Artificial</strong> and <strong>Intelligence</strong>, where Artificial defines <em>"man-made,"</em> and intelligence defines <em>"thinking power"</em>, hence AI means <em>"a man-made thinking power."</em></p>
<p>So, we can define AI as:</p>
<blockquote>
    "It is a branch of computer science by which we can create intelligent machines which can behave like a human, think like humans, and able to make decisions."
</blockquote>
<p>Artificial Intelligence exists when a machine can have human based skills such as learning, reasoning, and solving problems</p>
<p>With Artificial Intelligence you do not need to preprogram a machine to do some work, despite that you can create a machine with programmed algorithms which can work with own intelligence, and that is the awesomeness of AI.</p>
<p>It is believed that AI is not a new technology, and some people says that as per Greek myth, there were Mechanical men in early days which can work and behave like humans.</p>
<h2 class="h2">Why Artificial Intelligence?</h2>
<p>Before Learning about Artificial Intelligence, we should know that what is the importance of AI and why should we learn it. Following are some main reasons to learn about AI:</p>
<ul class="points">
<li>With the help of AI, you can create such software or devices which can solve real-world problems very easily and with accuracy such as health issues, marketing, traffic issues, etc.</li>
<li>With the help of AI, you can create your personal virtual Assistant, such as Cortana, Google Assistant, Siri, etc.</li>
<li>With the help of AI, you can build such Robots which can work in an environment where survival of humans can be at risk.</li>
<li>AI opens a path for other new technologies, new devices, and new Opportunities.</li>
</ul>
<h2 class="h2">Goals of Artificial Intelligence</h2>
<p>Following are the main goals of Artificial Intelligence:</p>
<ol class="points">
<li>Replicate human intelligence</li>
<li>Solve Knowledge-intensive tasks</li>
<li>An intelligent connection of perception and action</li>
<li>Building a machine which can perform tasks that requires human intelligence such as:
<ul class="points">
<li>Proving a theorem</li>
<li>Playing chess</li>
<li>Plan some surgical operation</li>
<li>Driving a car in traffic</li>
</ul>
</li>
<li>Creating some system which can exhibit intelligent behavior, learn new things by itself, demonstrate, explain, and can advise to its user. </li>
</ol>
<h2 class="h2">What Comprises to Artificial Intelligence? </h2>
<p>Artificial Intelligence is not just a part of computer science even it's so vast and requires lots of other factors which can contribute to it. To create the AI first we should know that how intelligence is composed, so the Intelligence is an intangible part of our brain which is a combination of <strong>Reasoning, learning, problem-solving perception, language understanding, etc</strong>.</p>
<p>To achieve the above factors for a machine or software Artificial Intelligence requires the following discipline:</p>
<ul class="points">
<li>Mathematics</li>
<li>Biology</li>
<li>Psychology</li>
<li>Sociology </li>
<li>Computer Science</li>
<li>Neurons Study</li>
<li>Statistics</li>
</ul>
<img alt="Introduction to AI" src="https://static.javatpoint.com/tutorial/ai/images/artificial-intelligence.png"/>
<h2 class="h2">Advantages of Artificial Intelligence</h2>
<p>Following are some main advantages of Artificial Intelligence:</p>
<ul class="points">
<li><strong>High Accuracy with less errors:</strong> AI machines or systems are prone to less errors and high accuracy as it takes decisions as per pre-experience or information.</li>
<li><strong>High-Speed:</strong> AI systems can be of very high-speed and fast-decision making, because of that AI systems can beat a chess champion in the Chess game.</li>
<li><strong>High reliability:</strong> AI machines are highly reliable and can perform the same action multiple times with high accuracy.</li>
<li><strong>Useful for risky areas:</strong> AI machines can be helpful in situations such as defusing a bomb, exploring the ocean floor, where to employ a human can be risky.</li>
<li><strong>Digital Assistant:</strong> AI can be very useful to provide digital assistant to the users such as AI technology is currently used by various E-commerce websites to show the products as per customer requirement. </li>
<li><strong>Useful as a public utility:</strong> AI can be very useful for public utilities such as a self-driving car which can make our journey safer and hassle-free, facial recognition for security purpose, Natural language processing to communicate with the human in human-language, etc.</li>
</ul>
<h2 class="h2">Disadvantages of Artificial Intelligence</h2>
<p>Every technology has some disadvantages, and thesame goes for Artificial intelligence. Being so advantageous technology still, it has some disadvantages which we need to keep in our mind while creating an AI system. Following are the disadvantages of AI: </p>
<ul class="points">
<li><strong>High Cost:</strong> The hardware and software requirement of AI is very costly as it requires lots of maintenance to meet current world requirements.</li>
<li><strong>Can't think out of the box:</strong> Even we are making smarter machines with AI, but still they cannot work out of the box, as the robot will only do that work for which they are trained, or programmed.</li>
<li><strong>No feelings and emotions:</strong> AI machines can be an outstanding performer, but still it does not have the feeling so it cannot make any kind of emotional attachment with human, and may sometime be harmful for users if the proper care is not taken.</li>
<li><strong>Increase dependency on machines:</strong> With the increment of technology, people are getting more dependent on devices and hence they are losing their mental capabilities.</li>
<li><strong>No Original Creativity:</strong> As humans are so creative and can imagine some new ideas but still AI machines cannot beat this power of human intelligence and cannot be creative and imaginative.</li>
</ul>
<h1 class="h1">Application of AI</h1>
<p>Artificial Intelligence has various applications in today's society. It is becoming essential for today's time because it can solve complex problems with an efficient way in multiple industries, such as Healthcare, entertainment, finance, education, etc. AI is making our daily life more comfortable and fast.</p>
<p>Following are some sectors which have the application of Artificial Intelligence:</p>
<img alt="Application of AI" src="https://static.javatpoint.com/tutorial/ai/images/application-of-ai.png"/>
<h3 class="h3">1. AI in Astronomy</h3>
<ul class="points">
<li>Artificial Intelligence can be very useful to solve complex universe problems. AI technology can be helpful for understanding the universe such as how it works, origin, etc.</li>
</ul>
<h3 class="h3">2. AI in Healthcare</h3>
<ul class="points">
<li>In the last, five to ten years, AI becoming more advantageous for the healthcare industry and going to have a significant impact on this industry.</li>
<li>Healthcare Industries are applying AI to make a better and faster diagnosis than humans. AI can help doctors with diagnoses and can inform when patients are worsening so that medical help can reach to the patient before hospitalization.</li>
</ul>
<h3 class="h3">3. AI in Gaming</h3>
<ul class="points">
<li>AI can be used for gaming purpose. The AI machines can play strategic games like chess, where the machine needs to think of a large number of possible places.</li>
</ul>
<h3 class="h3">4. AI in Finance</h3>
<ul class="points">
<li>AI and finance industries are the best matches for each other. The finance industry is implementing automation, chatbot, adaptive intelligence, algorithm trading, and machine learning into financial processes.</li>
</ul>
<h3 class="h3">5. AI in Data Security</h3>
<ul class="points">
<li>The security of data is crucial for every company and cyber-attacks are growing very rapidly in the digital world. AI can be used to make your data more safe and secure. Some examples such as AEG bot, AI2 Platform,are used to determine software bug and cyber-attacks in a better way.</li>
</ul>
<h3 class="h3">6. AI in Social Media</h3>
<ul class="points">
<li>Social Media sites such as Facebook, Twitter, and Snapchat contain billions of user profiles, which need to be stored and managed in a very efficient way. AI can organize and manage massive amounts of data. AI can analyze lots of data to identify the latest trends, hashtag, and requirement of different users.</li>
</ul>
<h3 class="h3">7. AI in Travel &amp;Transport</h3>
<ul class="points">
<li>AI is becoming highly demanding for travel industries. AI is capable of doing various travel related works such as from making travel arrangement to suggesting the hotels, flights, and best routes to the customers. Travel industries are using AI-powered chatbots which can make human-like interaction with customers for better and fast response.</li>
</ul>
<h3 class="h3">8. AI in Automotive Industry</h3>
<ul class="points">
<li>Some Automotive industries are using AI to provide virtual assistant to their user for better performance. Such as Tesla has introduced TeslaBot, an intelligent virtual assistant.</li>
<li>Various Industries are currently working for developing self-driven cars which can make your journey more safe and secure.</li>
</ul>
<h3 class="h3">9. AI in Robotics:</h3>
<ul class="points">
<li>Artificial Intelligence has a remarkable role in Robotics.  Usually, general robots are programmed such that they can perform some repetitive task, but with the help of AI, we can create intelligent robots which can perform tasks with their own experiences without pre-programmed.</li>
<li>Humanoid Robots are best examples for AI in robotics, recently the intelligent Humanoid robot named as Erica and Sophia has been developed which can talk and behave like humans.</li>
</ul>
<h3 class="h3">10. AI in Entertainment</h3>
<ul class="points">
<li>We are currently using some AI based applications in our daily life with some entertainment services such as Netflix or Amazon. With the help of ML/AI algorithms, these services show the recommendations for programs or shows.</li>
</ul>
<h3 class="h3">11. AI in Agriculture</h3>
<ul class="points">
<li>Agriculture is an area which requires various resources, labor, money, and time for best result. Now a day's agriculture is becoming digital, and AI is emerging in this field. Agriculture is applying AI as agriculture robotics, solid and crop monitoring, predictive analysis. AI in agriculture can be very helpful for farmers.</li>
</ul>
<h3 class="h3">12. AI in E-commerce</h3>
<ul class="points">
<li>AI is providing a competitive edge to the e-commerce industry, and it is becoming more demanding in the e-commerce business. AI is helping shoppers to discover associated products with recommended size, color, or even brand.</li>
</ul>
<h3 class="h3">13. AI in education:</h3>
<ul class="points">
<li>AI can automate grading so that the tutor can have more time to teach. AI chatbot can communicate with students as a teaching assistant.</li>
<li>AI in the future can be work as a personal virtual tutor for students, which will be accessible easily at any time and any place.</li>
</ul>
<h1 class="h1">History of Artificial Intelligence</h1>
<p>Artificial Intelligence is not a new word and not a new technology for researchers. This technology is much older than you would imagine. Even there are the myths of Mechanical men in Ancient Greek and Egyptian Myths. Following are some milestones in the history of AI which defines the journey from the AI generation to till date development. </p>
<img alt="History of Artificial Intelligence" src="https://static.javatpoint.com/tutorial/ai/images/history-of-ai.png"/>
<h2 class="h2">Maturation of Artificial Intelligence (1943-1952)</h2>
<ul class="points">
<li><strong>Year 1943:</strong> The first work which is now recognized as AI was done by Warren McCulloch and Walter pits in 1943. They proposed a model of <strong>artificial neurons</strong>. </li>
<li><strong>Year 1949:</strong> Donald Hebb demonstrated an updating rule for modifying the connection strength between neurons. His rule is now called <strong>Hebbian learning</strong>.</li>
<li><strong>Year 1950:</strong> The Alan Turing who was an English mathematician and pioneered Machine learning in 1950. Alan Turing publishes <strong>"Computing Machinery and Intelligence"</strong> in which he proposed a test. The test can check the machine's ability to exhibit intelligent behavior equivalent to human intelligence, called a <strong>Turing test</strong>.</li>
</ul>
<h2 class="h2">The birth of Artificial Intelligence (1952-1956)</h2>
<ul class="points">
<li><strong>Year 1955:</strong> An Allen Newell and Herbert A. Simon created the "first artificial intelligence program"Which was named as <strong>"Logic Theorist"</strong>. This program had proved 38 of 52 Mathematics theorems, and find new and more elegant proofs for some theorems.</li>
<li><strong>Year 1956:</strong> The word "Artificial Intelligence" first adopted by American Computer scientist John McCarthy at the Dartmouth Conference. For the first time, AI coined as an academic field.</li>
</ul>
<p>At that time high-level computer languages such as FORTRAN, LISP, or COBOL were invented. And the enthusiasm for AI was very high at that time.</p>
<h2 class="h2">The golden years-Early enthusiasm (1956-1974)</h2>
<ul class="points">
<li><strong>Year 1966:</strong> The researchers emphasized developing algorithms which can solve mathematical problems. Joseph Weizenbaum created the first chatbot in 1966, which was named as ELIZA. </li>
<li><strong>Year 1972:</strong> The first intelligent humanoid robot was built in Japan which was named as WABOT-1.</li>
</ul>
<h2 class="h2">The first AI winter (1974-1980)</h2>
<ul class="points">
<li>The duration between years 1974 to 1980 was the first AI winter duration. AI winter refers to the time period where computer scientist dealt with a severe shortage of funding from government for AI researches. </li>
<li>During AI winters, an interest of publicity on artificial intelligence was decreased. </li>
</ul>
<h2 class="h2">A boom of AI (1980-1987)</h2>
<ul class="points">
<li><strong>Year 1980:</strong> After AI winter duration, AI came back with "Expert System". Expert systems were programmed that emulate the decision-making ability of a human expert.</li>
<li>In the Year 1980, the first national conference of the American Association of Artificial Intelligence <strong>was held at Stanford University</strong>. </li>
</ul>
<h2 class="h2">The second AI winter (1987-1993)</h2>
<ul class="points">
<li>The duration between the years 1987 to 1993 was the second AI Winter duration.</li>
<li>Again Investors and government stopped in funding for AI research as due to high cost but not efficient result. The expert system such as XCON was very cost effective.</li>
</ul>
<h2 class="h2">The emergence of intelligent agents (1993-2011)</h2>
<ul class="points">
<li><strong>Year 1997:</strong> In the year 1997, IBM Deep Blue beats world chess champion, Gary Kasparov, and became the first computer to beat a world chess champion.</li>
<li><strong>Year 2002:</strong> for the first time, AI entered the home in the form of Roomba, a vacuum cleaner.</li>
<li><strong>Year 2006:</strong> AI came in the Business world till the year 2006. Companies like Facebook, Twitter, and Netflix also started using AI. </li>
</ul>
<h2 class="h2">Deep learning, big data and artificial general intelligence (2011-present) </h2>
<ul class="points">
<li><strong>Year 2011:</strong> In the year 2011, IBM's Watson won jeopardy, a quiz show, where it had to solve the complex questions as well as riddles. Watson had proved that it could understand natural language and can solve tricky questions quickly.</li>
<li><strong>Year 2012:</strong> Google has launched an Android app feature "Google now", which was able to provide information to the user as a prediction.</li>
<li><strong>Year 2014:</strong> In the year 2014, Chatbot "Eugene Goostman" won a competition in the infamous "Turing test."</li>
<li><strong>Year 2018:</strong> The "Project Debater" from IBM debated on complex topics with two master debaters and also performed extremely well.</li>
<li>Google has demonstrated an AI program "Duplex" which was a virtual assistant and which had taken hairdresser appointment on call, and lady on other side didn't notice that she was talking with the machine.</li>
</ul>
<p>Now AI has developed to a remarkable level. The concept of Deep learning, big data, and data science are now trending like a boom. Nowadays companies like Google, Facebook, IBM, and Amazon are working with AI and creating amazing devices. The future of Artificial Intelligence is inspiring and will come with high intelligence. </p>
<h1 class="h1">Types of Artificial Intelligence:</h1>
<p>Artificial Intelligence can be divided in various types, there are mainly two types of main categorization which are based on capabilities and based on functionally of AI. Following is flow diagram which explain the types of AI. </p>
<img alt="Types of Artificial Intelligence" src="https://static.javatpoint.com/tutorial/ai/images/types-of-artificial-intelligence.png"/>
<h2 class="h2">AI type-1: Based on Capabilities</h2>
<h3 class="h3">1. Weak AI or Narrow AI:</h3>
<ul class="points">
<li>Narrow AI is a type of AI which is able to perform a dedicated task with intelligence.The most common and currently available AI is Narrow AI in the world of Artificial Intelligence.</li>
<li>Narrow AI cannot perform beyond its field or limitations, as it is only trained for one specific task. Hence it is also termed as weak AI. Narrow AI can fail in unpredictable ways if it goes beyond its limits.</li>
<li>Apple Siriis a good example of Narrow AI, but it operates with a limited pre-defined range of functions.</li>
<li>IBM's Watson supercomputer also comes under Narrow AI, as it uses an Expert system approach combined with Machine learning and natural language processing.</li>
<li>Some Examples of Narrow AI are playing chess, purchasing suggestions on e-commerce site, self-driving cars, speech recognition, and image recognition. </li>
</ul>
<h3 class="h3">2. General AI:</h3>
<ul class="points">
<li>General AI is a type of intelligence which could perform any intellectual task with efficiency like a human.</li>
<li>The idea behind the general AI to make such a system which could be smarter and think like a human by its own.</li>
<li>Currently, there is no such system exist which could come under general AI and can perform any task as perfect as a human.</li>
<li>The worldwide researchers are now focused on developing machines with General AI.</li>
<li>As systems with general AI are still under research, and it will take lots of efforts and time to develop such systems. </li>
</ul>
<h3 class="h3">3. Super AI:</h3>
<ul class="points">
<li>Super AI is a level of Intelligence of Systems at which machines could surpass human intelligence, and can perform any task better than human with cognitive properties. It is an outcome of general AI.</li>
<li>Some key characteristics of strong AI include capability include the ability to think, to reason,solve the puzzle, make judgments, plan, learn, and communicate by its own.</li>
<li>Super AI is still a hypothetical concept of Artificial Intelligence. Development of such systems in real is still world changing task. </li>
</ul>
<img alt="Types of Artificial Intelligence" src="https://static.javatpoint.com/tutorial/ai/images/types-of-artificial-intelligence2.png"/>
<h2 class="h2">Artificial Intelligence type-2: Based on functionality</h2>
<h3 class="h3">1. Reactive Machines</h3>
<ul class="points">
<li>Purely reactive machines are the most basic types of Artificial Intelligence.</li>
<li>Such AI systems do not store memories or past experiences for future actions.</li>
<li>These machines only focus on current scenarios and react on it as per possible best action.</li>
<li>IBM's Deep Blue system is an example of reactive machines.</li>
<li>Google's AlphaGo is also an example of reactive machines. </li>
</ul>
<h3 class="h3">2. Limited Memory</h3>
<ul class="points">
<li>Limited memory machines can store past experiences or some data for a short period of time.</li>
<li>These machines can use stored data for a limited time period only.</li>
<li>Self-driving cars are one of the best examples of Limited Memory systems. These cars can store recent speed of nearby cars, the distance of other cars, speed limit, and other information to navigate the road. </li>
</ul>
<h3 class="h3">3. Theory of Mind</h3>
<ul class="points">
<li>Theory of Mind AI should understand the human emotions, people, beliefs, and be able to interact socially like humans.</li>
<li>This type of AI machines are still not developed, but researchers are making lots of efforts and improvement for developing such AI machines. </li>
</ul>
<h3 class="h3">4. Self-Awareness</h3>
<ul class="points">
<li>Self-awareness AI is the future of Artificial Intelligence. These machines will be super intelligent, and will have their own consciousness, sentiments, and self-awareness.</li>
<li>These machines will be smarter than human mind. </li>
<li>Self-Awareness AI does not exist in reality still and it is a hypothetical concept. </li>
</ul>
<h1 class="h1">Types of AI Agents</h1>
<p>Agents can be grouped into five classes based on their degree of perceived intelligence and capability. All these agents can improve their performance and generate better action over the time. These are given below: </p>
<ul class="points">
<li>Simple Reflex Agent</li>
<li>Model-based reflex agent</li>
<li>Goal-based agents</li>
<li>Utility-based agent</li>
<li>Learning agent</li>
</ul>
<h2 class="h2">1. Simple Reflex agent:</h2>
<ul class="points">
<li>The Simple reflex agents are the simplest agents. These agents take decisions on the basis of the current percepts and ignore the rest of the percept history.</li>
<li>These agents only succeed in the fully observable environment.</li>
<li>The Simple reflex agent does not consider any part of percepts history during their decision and action process.</li>
<li>The Simple reflex agent works on Condition-action rule, which means it maps the current state to action.  Such as a Room Cleaner agent, it works only if there is dirt in the room.</li>
<li>Problems for the simple reflex agent design approach:
<ul class="points">
<li>They have very limited intelligence</li>
<li>They do not have knowledge of non-perceptual parts of the current state</li>
<li>Mostly too big to generate and to store.</li>
<li>Not adaptive to changes in the environment.</li>
</ul>
</li>
</ul>
<img alt="Types of AI Agents" src="https://static.javatpoint.com/tutorial/ai/images/simple-reflex-agent.png"/>
<h2 class="h2">2. Model-based reflex agent</h2>
<ul class="points">
<li>The Model-based agent can work in a partially observable environment, and track the situation.</li>
<li>A model-based agent has two important factors:
<ul class="points">
<li><strong>Model:</strong> It is knowledge about "how things happen in the world," so it is called a Model-based agent.</li>
<li><strong>Internal State:</strong> It is a representation of the current state based on percept history. </li>
</ul></li>
<li>These agents have the model, "which is knowledge of the world" and based on the model  they perform actions. </li>
<li>Updating the agent state requires information about:
<ol class="pointsa">
<li>How the world evolves</li>
<li>How the agent's action affects the world.</li>
</ol></li>
</ul>
<img alt="Types of AI Agents" src="https://static.javatpoint.com/tutorial/ai/images/model-based-reflex-agent.png"/>
<h2 class="h2">3. Goal-based agents</h2>
<ul class="points">
<li>The knowledge of the current state environment is not always sufficient to decide for an agent to what to do. </li>
<li>The agent needs to know its goal which describes desirable situations.</li>
<li>Goal-based agents expand the capabilities of the model-based agent by having the "goal" information.</li>
<li>They choose an action, so that they can achieve the goal.</li>
<li>These agents may have to consider a long sequence of possible actions before deciding whether the goal is achieved or not. Such considerations of different scenario are called searching and planning, which makes an agent proactive. </li>
</ul>
<img alt="Types of AI Agents" src="https://static.javatpoint.com/tutorial/ai/images/goal-based-agent.png"/>
<h2 class="h2">4. Utility-based agents</h2>
<ul class="points">
<li>These agents are similar to the goal-based agent but provide an extra component of utility measurement which makes them different by providing a measure of success at a given state.</li>
<li>Utility-based agent act based not only goals but also the best way to achieve the goal.</li>
<li>The Utility-based agent is useful when there are multiple possible alternatives, and an agent has to choose in order to perform the best action. </li>
<li>The utility function maps each state to a real number to check how efficiently each action achieves the goals. </li>
</ul>
<img alt="Types of AI Agents" src="https://static.javatpoint.com/tutorial/ai/images/utility-based-agent.png"/>
<h2 class="h2">5. Learning Agents</h2>
<ul class="points">
<li>A learning agent in AI is the type of agent which can learn from its past experiences, or it has learning capabilities.</li>
<li>It starts to act with basic knowledge and then able to act and adapt automatically through learning. </li>
<li>A learning agent has mainly four conceptual components, which are:
<ol class="pointsa">
<li><strong>Learning element:</strong> It is responsible for making improvements by learning from environment</li>
<li><strong>Critic:</strong> Learning element takes feedback from critic which describes that how well the agent is doing with respect to a fixed performance standard.</li>
<li><strong>Performance element:</strong> It is responsible for selecting external action</li>
<li><strong>Problem generator:</strong> This component is responsible for suggesting actions that will lead to new and informative experiences. </li>
</ol></li>
<li>Hence, learning agents are able to learn, analyze performance, and look for new ways to improve the performance. </li>
</ul>
<img alt="Types of AI Agents" src="https://static.javatpoint.com/tutorial/ai/images/learning-agent.png"/>
<h1 class="h1">Agents in Artificial Intelligence</h1>
<p>An AI system can be defined as the study of the rational agent and its environment. The agents sense the environment through sensors and act on their environment through actuators. An AI agent can have mental properties such as knowledge, belief, intention, etc. </p>
<h2 class="h2">What is an Agent?</h2>
<p>An agent can be anything that perceiveits environment through sensors and act upon that environment through actuators. An Agent runs in the cycle of <strong>perceiving</strong>, <strong>thinking</strong>, and <strong>acting</strong>. An agent can be:</p>
<ul class="points">
<li><strong>Human-Agent:</strong> A human agent has eyes, ears, and other organs which work for sensors and hand, legs, vocal tract work for actuators.</li>
<li><strong>Robotic Agent:</strong> A robotic agent can have cameras, infrared range finder, NLP for sensors and various motors for actuators.</li>
<li><strong>Software Agent:</strong> Software agent can have keystrokes, file contents as sensory input and act on those inputs and display output on the screen.</li>
</ul>
<p>Hence the world around us is full of agents such as thermostat, cellphone, camera, and even we are also agents.</p>
<p>Before moving forward, we should first know about sensors, effectors, and actuators.</p>
<p><strong>Sensor:</strong> Sensor is a device which detects the change in the environment and sends the information to other electronic devices. An agent observes its environment through sensors.</p>
<p><strong>Actuators:</strong> Actuators are the component of machines that converts energy into motion. The actuators are only responsible for moving and controlling a system. An actuator can be an electric motor, gears, rails, etc.</p>
<p><strong>Effectors:</strong> Effectors are the devices which affect the environment. Effectors can be legs, wheels, arms, fingers, wings, fins, and display screen.</p>
<img alt="Agents in AI" src="https://static.javatpoint.com/tutorial/ai/images/agents-in-ai.png"/>
<h2 class="h2">Intelligent Agents:</h2>
<p>An intelligent agent is an autonomous entity which act upon an environment using sensors and actuators for achieving goals. An intelligent agent may learn from the environment to achieve their goals. A thermostat is an example of an intelligent agent. </p>
<p>Following are the main four rules for an AI agent:</p>
<ul class="points">
<li><strong>Rule 1:</strong> An AI agent must have the ability to perceive the environment.</li>
<li><strong>Rule 2:</strong> The observation must be used to make decisions.</li>
<li><strong>Rule 3:</strong> Decision should result in an action.</li>
<li><strong>Rule 4:</strong> The action taken by an AI agent must be a rational action.</li>
</ul>
<h2 class="h2">Rational Agent: </h2>
<p>A rational agent is an agent which has clear preference, models uncertainty, and acts in a way to maximize its performance measure with all possible actions.</p>
<p>A rational agent is said to perform the right things. AI is about creating rational agents to use for game theory and decision theory for various real-world scenarios.</p>
<p>For an AI agent, the rational action is most important because in AI reinforcement learning algorithm, for each best possible action, agent gets the positive reward and for each wrong action, an agent gets a negative reward.</p>
<h4 class="n">Note: Rational agents in AI are very similar to intelligent agents. </h4>
<h3 class="h3">Rationality:</h3>
<p>The rationality of an agent is measured by its performance measure. Rationality can be judged on the basis of following points:</p>
<ul class="points">
<li>Performance measure which defines the success criterion.</li>
<li>Agent prior knowledge of its environment.</li>
<li>Best possible actions that an agent can perform.</li>
<li>The sequence of percepts. </li>
</ul>
<h4 class="n">Note: Rationality differs from Omniscience because an Omniscient agent knows the actual outcome of its action and act accordingly, which is not possible in reality.</h4>
<h2 class="h2">Structure of an AI Agent</h2>
<p>The task of AI is to design an agent program which implements the agent function. The structure of an intelligent agent is a combination of architecture and agent program. It can be viewed as:</p>
<div class="codeblock"><textarea class="java" name="code">
       Agent = Architecture + Agent program
</textarea></div>
<p>Following are the main three terms involved in the structure of an AI agent: </p>
<p><strong>Architecture:</strong> Architecture is machinery that an AI agent executes on.</p>
<p><strong>Agent Function:</strong> Agent function is used to map a percept to an action. </p>
<div class="codeblock"><textarea class="java" name="code">
       f:P* → A
</textarea></div>
<p><strong>Agent program:</strong> Agent program is an implementation of agent function. An agent program executes on the physical architecture to produce function f. </p>
<h2 class="h2">PEAS Representation</h2>
<p>PEAS is a type of model on which an AI agent works upon. When we define an AI agent or rational agent, then we can group its properties under PEAS representation model. It is made up of four words:</p>
<ul class="points">
<li><strong>P:</strong> Performance measure</li>
<li><strong>E:</strong> Environment</li>
<li><strong>A:</strong> Actuators</li>
<li><strong>S:</strong> Sensors</li>
</ul>
<p>Here performance measure is the objective for the success of an agent's behavior.</p>
<h3 class="h3">PEAS for self-driving cars:</h3>
<img alt="Agents in AI" src="https://static.javatpoint.com/tutorial/ai/images/peas-for-self-driving-cars.png"/>
<p>Let's suppose a self-driving car then PEAS representation will be: </p>
<p><strong>Performance:</strong> Safety, time, legal drive, comfort</p>
<p><strong>Environment:</strong> Roads, other vehicles, road signs, pedestrian</p>
<p><strong>Actuators:</strong> Steering, accelerator, brake, signal, horn</p>
<p><strong>Sensors:</strong> Camera, GPS, speedometer, odometer, accelerometer, sonar.</p>
<h2 class="h2">Example of Agents with their PEAS representation</h2>
<table class="alt">
<tr>
<th>Agent</th>
<th>Performance measure</th>
<th>Environment</th>
<th>Actuators</th>
<th>Sensors</th>
</tr>
<tr>
<td><strong>1. Medical Diagnose</strong></td>
<td><ul class="points">
<li>Healthy patient</li>
<li>Minimized cost</li>
</ul></td>
<td><ul class="points">
<li>Patient</li>
<li>Hospital</li>
<li>Staff</li>
</ul></td>
<td><ul class="points">
<li>Tests</li>
<li>Treatments</li>
</ul></td>
<td>Keyboard<br/>
(Entry of symptoms)</td>
</tr>
<tr>
<td><strong>2. Vacuum Cleaner</strong></td>
<td><ul class="points">
<li>Cleanness</li>
<li>Efficiency</li>
<li>Battery life</li>
<li>Security</li>
</ul></td>
<td><ul class="points">
<li>Room</li>
<li>Table</li>
<li>Wood floor</li>
<li>Carpet</li>
<li>Various obstacles</li>
</ul></td>
<td><ul class="points">
<li>Wheels</li>
<li>Brushes</li>
<li>Vacuum Extractor</li>
</ul></td>
<td><ul class="points">
<li>Camera</li>
<li>Dirt detection sensor</li>
<li>Cliff sensor</li>
<li>Bump Sensor</li>
<li>Infrared Wall Sensor</li>
</ul></td>
</tr>
<tr>
<td><strong>3. Part -picking Robot</strong></td>
<td><ul class="points">
<li>Percentage of parts in correct bins.</li>
</ul></td>
<td><ul class="points">
<li>Conveyor belt with parts,</li>
<li>Bins</li>
</ul></td>
<td><ul class="points">
<li>Jointed Arms</li>
<li>Hand</li>
</ul></td>
<td><ul class="points">
<li>Camera</li>
<li>Joint angle sensors.</li>
</ul></td>
</tr>
</table>
<h1 class="h1">Agent Environment in AI</h1>
<p>An environment is everything in the world which surrounds the agent, but it is not a part of an agent itself. An environment can be described as a situation in which an agent is present.</p>
<p>The environment is where agent lives, operate and provide the agent with something to sense and act upon it. An environment is mostly said to be non-feministic.</p>
<h2 class="h2">Features of Environment</h2>
<p>As per Russell and Norvig, an environment can have various features from the point of view of an agent:</p>
<ol class="points">
<li>Fully observable vs Partially Observable</li>
<li>Static vs Dynamic</li>
<li>Discrete vs Continuous</li>
<li>Deterministic vs Stochastic</li>
<li>Single-agent vs Multi-agent</li>
<li>Episodic vs  sequential</li>
<li>Known vs Unknown</li>
<li>Accessible vs Inaccessible</li>
</ol>
<h2 class="h3">1. Fully observable vs Partially Observable:</h2>
<ul class="points">
<li>If an agent sensor can sense or access the complete state of an environment at each point of time then it is <strong>a fully observable</strong> environment, else it is <strong>partially observable</strong>.</li>
<li>A fully observable environment is easy as there is no need to maintain the internal state to keep track history of the world.</li>
<li>An agent with no sensors in all environments then such an environment is called as <strong>unobservable</strong>.</li>
</ul>
<h2 class="h3">2. Deterministic vs Stochastic:</h2>
<ul class="points">
<li>If an agent's current state and selected action can completely determine the next state of the environment, then such environment is called a deterministic environment.</li>
<li>A stochastic environment is random in nature and cannot be determined completely by an agent.</li>
<li>In a deterministic, fully observable environment, agent does not need to worry about uncertainty.</li>
</ul>
<h2 class="h3">3. Episodic vs Sequential:</h2>
<ul class="points">
<li>In an episodic environment, there is a series of one-shot actions, and only the current percept is required for the action.</li>
<li>However, in Sequential environment, an agent requires memory of past actions to determine the next best actions.</li>
</ul>
<h2 class="h3">4. Single-agent vs Multi-agent</h2>
<ul class="points">
<li>If only one agent is involved in an environment, and operating by itself then such an environment is called single agent environment.</li>
<li>However, if multiple agents are operating in an environment, then such an environment is called a multi-agent environment.</li>
<li>The agent design problems in the multi-agent environment are different from single agent environment.</li>
</ul>
<h2 class="h3">5. Static vs Dynamic:</h2>
<ul class="points">
<li>If the environment can change itself while an agent is deliberating then such environment is called a dynamic environment else it is called a static environment.</li>
<li>Static environments are easy to deal because an agent does not need to continue looking at the world while deciding for an action.</li>
<li>However for dynamic environment, agents need to keep looking at the world at each action.</li>
<li>Taxi driving is an example of a dynamic environment whereas Crossword puzzles are an example of a static environment.</li>
</ul>
<h2 class="h3">6. Discrete vs Continuous:</h2>
<ul class="points">
<li>If in an environment there are a finite number of percepts and actions that can be performed within it, then such an environment is called a discrete environment else it is called continuous environment.</li>
<li>A chess gamecomes under discrete environment as there is a finite number of moves that can be performed.</li>
<li>A self-driving car is an example of a continuous environment.</li>
</ul>
<h2 class="h3">7. Known vs Unknown</h2>
<ul class="points">
<li>Known and unknown are not actually a feature of an environment, but it is an agent's state of knowledge to perform an action.</li>
<li>In a known environment, the results for all actions are known to the agent. While in unknown environment, agent needs to learn how it works in order to perform an action.</li>
<li>It is quite possible that a known environment to be partially observable and an Unknown environment to be fully observable.</li>
</ul>
<h2 class="h3">8. Accessible vs Inaccessible</h2>
<ul class="points">
<li>If an agent can obtain complete and accurate information about the state's environment, then such an environment is called an Accessible environment else it is called inaccessible.</li>
<li>An empty room whose state can be defined by its temperature is an example of an accessible environment.</li>
<li>Information about an event on earth is an example of Inaccessible environment.</li>
</ul>
<h1 class="h1">Turing Test in AI</h1>
<p>In 1950, Alan Turing introduced a test to check whether a machine can think like a human or not, this test is known as the Turing Test. In this test, Turing proposed that the computer can be said to be an intelligent if it can mimic human response under specific conditions.</p>
<p>Turing Test was introduced by Turing in his 1950 paper, "Computing Machinery and Intelligence," which considered the question, "Can Machine think?"</p>
<img alt="Turing Test in AI" src="https://static.javatpoint.com/tutorial/ai/images/turing-test-in-ai.png"/><br/>
<p>The Turing test is based on a party game "Imitation game," with some modifications. This game involves three players in which one player is Computer, another player is human responder, and the third player is a human Interrogator, who is isolated from other two players and his job is to find that which player is machine among two of them.</p>
<p>Consider, Player A is a computer, Player B is human, and Player C is an interrogator. Interrogator is aware that one of them is machine, but he needs to identify this on the basis of questions and their responses.</p>
<p>The conversation between all players is via keyboard and screen so the result would not depend on the machine's ability to convert words as speech.</p>
<p>The test result does not depend on each correct answer, but only how closely its responses like a human answer. The computer is permitted to do everything possible to force a wrong identification by the interrogator.</p>
<p>The questions and answers can be like:</p>
<p><strong>Interrogator:</strong> Are you a computer?</p>
<p><strong>PlayerA (Computer):</strong> No</p>
<p><strong>Interrogator:</strong> Multiply two large numbers such as (256896489*456725896)</p>
<p><strong>Player A:</strong> Long pause and give the wrong answer.</p>
<p>In this game, if an interrogator would not be able to identify which is a machine and which is human, then the computer passes the test successfully, and the machine is said to be intelligent and can think like a human.</p>
<p>"In 1991, the New York businessman Hugh Loebner announces the prize competition, offering a $100,000 prize for the first computer to pass the Turing test. However, no AI program to till date, come close to passing an undiluted Turing test".</p>
<h2 class="h2">Chatbots to attempt the Turing test:</h2>
<p><strong>ELIZA:</strong> ELIZA was a Natural language processing computer program created by Joseph Weizenbaum. It was created to demonstrate the ability of communication between machine and humans. It was one of the first chatterbots, which has attempted the Turing Test.</p>
<p><strong>Parry:</strong> Parry was a chatterbot created by Kenneth Colby in 1972. Parry was designed to simulate a person with <strong>Paranoid schizophrenia</strong>(most common chronic mental disorder). Parry was described as "ELIZA with attitude."  Parry was tested using a variation of the Turing Test in the early 1970s.</p>
<p><strong>Eugene Goostman:</strong> Eugene Goostman was a chatbot developed in Saint Petersburg in 2001. This bot has competed in the various number of Turing Test. In June 2012, at an event, Goostman won the competition promoted as largest-ever Turing test content, in which it has convinced 29% of judges that it was a human.Goostman resembled as a 13-year old virtual boy.</p>
<h2 class="h2">The Chinese Room Argument:</h2>
<p>There were many philosophers who really disagreed with the complete concept of Artificial Intelligence. The most famous argument in this list was "<strong>Chinese Room</strong>."</p>
<p>In the year <strong>1980, John Searle</strong> presented "<strong>Chinese Room</strong>" thought experiment, in his paper "<strong>Mind, Brains, and Program</strong>," which was against the validity of Turing's Test. According to his argument, "<strong>Programming a computer may make it to understand a language, but it will not produce a real understanding of language or consciousness in a computer</strong>."</p>
<p>He argued that Machine such as ELIZA and Parry could easily pass the Turing test by manipulating keywords and symbol, but they had no real understanding of language. So it cannot be described as "thinking" capability of a machine such as a human.</p>
<h2 class="h2">Features required for a machine to pass the Turing test:</h2>
<ul class="points">
<li><strong>Natural language processing:</strong> NLP is required to communicate with Interrogator in general human language like English.</li>
<li><strong>Knowledge representation:</strong> To store and retrieve information during the test.</li>
<li><strong>Automated reasoning:</strong> To use the previously stored information for answering the questions.</li>
<li><strong>Machine learning:</strong> To adapt new changes and can detect generalized patterns.</li>
<li><strong>Vision (For total Turing test):</strong> To recognize the interrogator actions and other objects during a test.</li>
<li><strong>Motor Control (For total Turing test):</strong> To act upon objects if requested.</li>
</ul>
<h1 class="h1">Search Algorithms in Artificial Intelligence</h1>
<p>Search algorithms are one of the most important areas of Artificial Intelligence. This topic will explain all about the search algorithms in AI.</p>
<h3 class="h3">Problem-solving agents: </h3>
<p>In Artificial Intelligence, Search techniques are universal problem-solving methods. <strong>Rational agents</strong> or <strong>Problem-solving agents</strong> in AI mostly used these search strategies or algorithms to solve a specific problem and provide the best result. Problem-solving agents are the goal-based agents and use atomic representation. In this topic, we will learn various problem-solving search algorithms. </p>
<h2 class="h2">Search Algorithm Terminologies: </h2>
<ul class="points">
<li><strong>Search:</strong> Searchingis a step by step procedure to solve a search-problem in a given search space. A search problem can have three main factors:
<ol class="pointsa">
<li><strong>Search Space:</strong> Search space represents a set of possible solutions, which a system may have.</li>
<li><strong>Start State:</strong> It is a state from where agent begins <strong>the search</strong>.</li>
<li><strong>Goal test:</strong> It is a function which observe the current state and returns whether the goal state is achieved or not.</li>
</ol></li>
<li><strong>Search tree:</strong> A tree representation of search problem is called Search tree. The root of the search tree is the root node which is corresponding to the initial state.</li>
<li><strong>Actions:</strong> It gives the description of all the available actions to the agent.</li>
<li><strong>Transition model:</strong> A description of what each action do, can be represented as a transition model.</li>
<li><strong>Path Cost:</strong> It is a function which assigns a numeric cost to each path.</li>
<li><strong>Solution:</strong> It is an action sequence which leads from the start node to the goal node.</li>
<li><strong>Optimal Solution:</strong> If a solution has the lowest cost among all solutions.</li>
</ul>
<h2 class="h2">Properties of Search Algorithms:</h2>
<p>Following are the four essential properties of search algorithms to compare the efficiency of these algorithms:</p>
<p><strong>Completeness:</strong> A search algorithm is said to be complete if it guarantees to return a solution if at least any solution exists for any random input.</p>
<p><strong>Optimality:</strong> If a solution found for an algorithm is guaranteed to be the best solution (lowest path cost) among all other solutions, then such a solution for is said to be an optimal solution.</p>
<p><strong>Time Complexity:</strong> Time complexity is a measure of time for an algorithm to complete its task.</p>
<p><strong>Space Complexity:</strong> It is the maximum storage space required at any point during the search, as the complexity of the problem.</p>
<h2 class="h2">Types of search algorithms</h2>
<p><strong>Based on the search problems we can classify the search algorithms into uninformed (Blind search) search and informed search (Heuristic search) algorithms. </strong></p>
<img alt="Search Algorithms in Artificial Intelligence" src="https://static.javatpoint.com/tutorial/ai/images/types-of-search-algorithms.png"/>
<h3 class="h3">Uninformed/Blind Search:</h3>
<p>The uninformed search does not contain any domain knowledge such as closeness, the location of the goal. It operates in a brute-force way as it only includes information about how to traverse the tree and how to identify leaf and goal nodes. Uninformed search applies a way in which search tree is searched without any information about the search space like initial state operators and test for the goal, so it is also called blind search.It examines each node of the tree until it achieves the goal node.</p>
<p><strong>It can be divided into five main types:</strong></p>
<ul class="points">
<li>Breadth-first search</li>
<li>Uniform cost search</li>
<li>Depth-first search</li>
<li>Iterative deepening depth-first search</li>
<li>Bidirectional Search</li>
</ul>
<h3 class="h3">Informed Search</h3>
<p>Informed search algorithms use domain knowledge. In an informed search, problem information is available which can guide the search. Informed search strategies can find a solution more efficiently than an uninformed search strategy. Informed search is also called a Heuristic search.</p>
<p>A heuristic is a way which might not always be guaranteed for best solutions but guaranteed to find a good solution in reasonable time.</p>
<p>Informed search can solve much complex problem which could not be solved in another way.</p>
<p>An example of informed search algorithms is a traveling salesman problem.</p>
<ol class="points">
<li>Greedy Search</li>
<li>A* Search</li>
</ol>
<h1 class="h1">Uninformed Search Algorithms</h1>
<p><strong>Uninformed search is a class of general-purpose search algorithms which operates in brute force-way. Uninformed search algorithms do not have additional information about state or search space other than how to traverse the tree, so it is also called blind search.</strong></p>
<p><strong>Following are the various types of uninformed search algorithms:</strong></p>
<ol class="points">
<li><strong>Breadth-first Search</strong></li>
<li><strong>Depth-first Search </strong></li>
<li><strong>Depth-limited Search</strong></li>
<li><strong>Iterative deepening depth-first search</strong></li>
<li><strong>Uniform cost search</strong></li>
<li><strong>Bidirectional Search</strong></li>
</ol>
<h2 class="h2">1. Breadth-first Search:</h2>
<ul class="points">
<li>Breadth-first search is the most common search strategy for traversing a tree or graph. This algorithm searches breadthwise in a tree or graph, so it is called breadth-first search.</li>
<li>BFS algorithm starts searching from the root node of the tree and expands all successor node at the current level before moving to nodes of next level.</li>
<li>The breadth-first search algorithm is an example of a general-graph search algorithm. </li>
<li>Breadth-first search implemented using FIFO queue data structure.</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul class="points">
<li>BFS will provide a solution if any solution exists.</li>
<li>If there are more than one solutions for a given problem, then BFS will provide the minimal solution which requires the least number of steps. </li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul class="points">
<li>It requires lots of memory since each level of the tree must be saved into memory to expand the next level.</li>
<li>BFS needs lots of time if the solution is far away from the root node.</li>
</ul>
<h3 class="h3">Example: </h3>
<p>In the below tree structure, we have shown the traversing of the tree using BFS algorithm from the root node S to goal node K. BFS search algorithm traverse in layers, so it will follow the path which is shown by the dotted arrow, and the traversed path will be:</p>
<div class="codeblock"><textarea class="java" name="code">
S---&gt; A---&gt;B----&gt;C---&gt;D----&gt;G---&gt;H---&gt;E----&gt;F----&gt;I----&gt;K
</textarea></div>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/breadth-first-search.png"/>
<p><strong>Time Complexity:</strong> Time Complexity of BFS algorithm can be obtained by the number of nodes traversed in BFS until the shallowest Node. Where the d= depth of shallowest solution and b is a node at every state.</p>
<p><strong>T (b) = 1+b<sup>2</sup>+b<sup>3</sup>+.......+ b<sup>d</sup>= O (b<sup>d</sup>)</strong></p>
<p><strong>Space Complexity:</strong> Space complexity of BFS algorithm is given by the Memory size of frontier which is O(b<sup>d</sup>).</p>
<p><strong>Completeness:</strong> BFS is complete, which means if the shallowest goal node is at some finite depth, then BFS will find a solution.</p>
<p><strong>Optimality:</strong> BFS is optimal if path cost is a non-decreasing function of the depth of the node.</p>
<h2 class="h2">2. Depth-first Search</h2>
<ul class="points">
<li>Depth-first search isa recursive algorithm for traversing a tree or graph data structure.</li>
<li>It is called the depth-first search because it starts from the root node and follows each path to its greatest depth node before moving to the next path.</li>
<li>DFS uses a stack data structure for its implementation.</li>
<li>The process of the DFS algorithm is similar to the BFS algorithm.</li>
</ul>
<h4 class="n">Note: Backtracking is an algorithm technique for finding all possible solutions using recursion. </h4>
<p><strong>Advantage:</strong></p>
<ul class="points">
<li>DFS requires very less memory as it only needs to store a stack of the nodes on the path from root node to the current node.</li>
<li>It takes less time to reach to the goal node than BFS algorithm (if it traverses in the right path).</li>
</ul>
<p><strong>Disadvantage: </strong></p>
<ul class="points">
<li>There is the possibility that many states keep re-occurring, and there is no guarantee of finding the solution.</li>
<li>DFS algorithm goes for deep down searching and sometime it may go to the infinite loop. </li>
</ul>
<h3 class="h3">Example: </h3>
<p>In the below search tree, we have shown the flow of depth-first search, and it will follow the order as:</p>
<p>Root node---&gt;Left node ----&gt; right node.</p>
<p>It will start searching from root node S, and traverse A, then B, then D and E, after traversing E, it will backtrack the tree as E has no other successor and still goal node is not found. After backtracking it will traverse node C and then G, and here it will terminate as it found goal node.</p>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/depth-first-search.png"/>
<p><strong>Completeness:</strong> DFS search algorithm is complete within finite state space as it will expand every node within a limited search tree.</p>
<p><strong>Time Complexity:</strong> Time complexity of DFS will be equivalent to the node traversed by the algorithm. It is given by:</p>
<p><strong>T(n)= 1+ n<sup>2</sup>+ n<sup>3</sup> +.........+ n<sup>m</sup>=O(n<sup>m</sup>)</strong></p>
<p><strong>Where, m= maximum depth of any node and this can be much larger than d (Shallowest solution depth)</strong></p>
<p><strong>Space Complexity:</strong> DFS algorithm needs to store only single path from the root node, hence space complexity of DFS is equivalent to the size of the fringe set, which is <strong>O(bm)</strong>.</p>
<p><strong>Optimal:</strong> DFS search algorithm is non-optimal, as it may generate a large number of steps or high cost to reach to the goal node.</p>
<h2 class="h2">3. Depth-Limited Search Algorithm:</h2>
<p>A depth-limited search algorithm is similar to depth-first search with a predetermined limit. Depth-limited search can solve the drawback of the infinite path in the Depth-first search. In this algorithm, the node at the depth limit will treat as it has no successor nodes further.</p>
<p>Depth-limited search can be terminated with two Conditions of failure:</p>
<ul class="points">
<li>Standard failure value: It indicates that problem does not have any solution.</li>
<li>Cutoff failure value: It defines no solution for the problem within a given depth limit.</li>
</ul>
<p><strong>Advantages:</strong></p>
<p>Depth-limited search is Memory efficient. </p>
<p><strong>Disadvantages:</strong></p>
<ul class="points">
<li>Depth-limited search also has a disadvantage of incompleteness.</li>
<li>It may not be optimal if the problem has more than one solution.</li>
</ul>
<h3 class="h3">Example:</h3>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/depth-limited-search-algorithm.png"/>
<p><strong>Completeness:</strong> DLS search algorithm is complete if the solution is above the depth-limit.</p>
<p><strong>Time Complexity:</strong> Time complexity of DLS algorithm is <strong>O(b<sup>ℓ</sup>)</strong>. </p>
<p><strong>Space Complexity:</strong> Space complexity of DLS algorithm is O<strong>(b×ℓ)</strong>.</p>
<p><strong>Optimal:</strong> Depth-limited search can be viewed as a special case of DFS, and it is also not optimal even if ℓ&gt;d.</p>
<h2 class="h2">4. Uniform-cost Search Algorithm:</h2>
<p>Uniform-cost search is a searching algorithm used for traversing a weighted tree or graph. This algorithm comes into play when a different cost is available for each edge. The primary goal of the uniform-cost search is to find a path to the goal node which has the lowest cumulative cost. Uniform-cost search expands nodes according to their path costs form the root node. 
It can be used to solve any graph/tree where the optimal cost is in demand. 	
A uniform-cost search algorithm is implemented by the priority queue. It gives maximum priority to the lowest cumulative cost. 
Uniform cost search is equivalent to BFS algorithm if the path cost of all edges is the same. 
<p><strong>Advantages:</strong></p>
<ul class="points">
<li>Uniform cost search is optimal because at every state the path with the least cost is chosen.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul class="points">
<li>It does not care about the number of steps involve in searching and only concerned about path cost. Due to which this algorithm may be stuck in an infinite loop.</li>
</ul>
<h3 class="h3">Example:</h3>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/uniform-cost-search-algorithm.png"/>
<p><strong>Completeness:</strong></p>
<p>Uniform-cost search is complete, such as if there is a solution, UCS will find it.</p>
<p><strong>Time Complexity:</strong></p>
<p>Let C* <strong>is Cost of the optimal solution</strong>, and <strong>ε</strong> is each step to get closer to the goal node. Then the number of steps is = C*/ε+1. Here we have taken +1, as we start from state 0 and end to C*/ε.</p>
<p>Hence, the worst-case time complexity of Uniform-cost search is<strong>O(b<sup>1 + [C*/ε]</sup>)/</strong>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The same logic is for space complexity so, the worst-case space complexity of Uniform-cost search is <strong>O(b<sup>1 + [C*/ε]</sup>)</strong>.</p>
<p><strong>Optimal:</strong></p>
<p>Uniform-cost search is always optimal as it only selects a path with the lowest path cost.</p>
<h2 class="h2">5. Iterative deepeningdepth-first Search:</h2>
<p>The iterative deepening algorithm is a combination of DFS and BFS algorithms. This search algorithm finds out the best depth limit and does it by gradually increasing the limit until a goal is found.</p>
<p>This algorithm performs depth-first search up to a certain "depth limit", and it keeps increasing the depth limit after each iteration until the goal node is found.</p>
<p>This Search algorithm combines the benefits of Breadth-first search's fast search and depth-first search's memory efficiency.</p>
<p>The iterative search algorithm is useful uninformed search when search space is large, and depth of goal node is unknown.</p>
<p><strong>Advantages:</strong></p>
<ul class="points">
<li>Itcombines the benefits of BFS and DFS search algorithm in terms of fast search and memory efficiency.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul class="points">
<li>The main drawback of IDDFS is that it repeats all the work of the previous phase.</li>
</ul>
<h3 class="h3">Example: </h3>
<p>Following tree structure is showing the iterative deepening depth-first search. IDDFS algorithm performs various iterations until it does not find the goal node. The iteration performed by the algorithm is given as:</p>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/iterative-deepeningdepth-first-search.png"/>
<p>1'st Iteration-----&gt; A <br/>
2'nd Iteration----&gt; A, B, C<br/>
3'rd Iteration------&gt;A, B, D, E, C, F, G<br/>
4'th Iteration------&gt;A, B, D, H, I, E, C, F, K, G<br/>
In the fourth iteration, the algorithm will find the goal node.</p>
<p><strong>Completeness:</strong></p>
<p>This algorithm is complete is ifthe branching factor is finite.</p>
<p><strong>Time Complexity:</strong></p>
<p>Let's suppose b is the branching factor and depth is d then the worst-case time complexity is <strong>O(b<sup>d</sup>)</strong>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of IDDFS will be <strong>O(bd)</strong>.</p>
<p><strong>Optimal:</strong></p>
<p>IDDFS algorithm is optimal if path cost is a non- decreasing function of the depth of the node.</p>
<h2 class="h2">6. Bidirectional Search Algorithm:</h2>
<p><strong>Bidirectional search algorithm runs two simultaneous searches, one form initial state called as forward-search and other from goal node called as backward-search, to find the goal node. Bidirectional search replaces one single search graph with two small subgraphs in which one starts the search from an initial vertex and other starts from goal  vertex. The search stops when these two graphs intersect each other.</strong></p>
<p><strong>Bidirectional search can use search techniques such as BFS, DFS, DLS, etc.</strong></p>
<p><strong>Advantages:</strong></p>
<ul class="points">
<li>Bidirectional search is fast.</li>
<li>Bidirectional search requires less memory</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul class="points">
<li>Implementation of the bidirectional search tree is difficult.</li>
<li><strong>In bidirectional search, one should know the goal state in advance.</strong></li>
</ul>
<h3 class="h3">Example: </h3>
<p>In the below search tree, bidirectional search algorithm is applied. This algorithm divides one graph/tree into two sub-graphs. It starts traversing from node 1 in the forward direction and starts from goal node 16 in the backward direction.</p>
<p>The algorithm terminates at node 9 where two searches meet.</p>
<img alt="Uninformed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/bidirectional-search-algorithm.png"/>
<p><strong>Completeness:</strong> Bidirectional Search is complete if we use BFS in both searches.</p>
<p><strong>Time Complexity:</strong> Time complexity of bidirectional search using BFS is <strong>O(b<sup>d</sup>)</strong>.</p>
<p><strong>Space Complexity:</strong> Space complexity of bidirectional search is <strong>O(b<sup>d</sup>)</strong>.</p>
<p><strong>Optimal:</strong> Bidirectional search is Optimal.</p>
<h1 class="h1">Informed Search Algorithms</h1>
<p>So far we have talked about the uninformed search algorithms which looked through search space for all possible solutions of the problem without having any additional knowledge about search space. But informed search algorithm contains an array of knowledge such as how far we are from the goal, path cost, how to reach to goal node, etc. This knowledge help agents to explore less to the search space and find more efficiently the goal node.</p>
<p>The informed search algorithm is more useful for large search space. Informed search algorithm uses the idea of heuristic, so it is also called Heuristic search.</p>
<p><strong>Heuristics function:</strong> Heuristic is a function which is used in Informed Search, and it finds the most promising path. It takes the current state of the agent as its input and produces the estimation of how close agent is from the goal. The heuristic method, however, might not always give the best solution, but it guaranteed to find a good solution in reasonable time. Heuristic function estimates how close a state is to the goal. It is represented by h(n), and it calculates the cost of an optimal path between the pair of states. The value of the heuristic function is always positive.</p>
<p><strong>Admissibility of the heuristic function is given as:</strong></p>
<div class="codeblock"><textarea class="java" name="code">
     h(n) &lt;= h*(n)
</textarea></div>
<p><strong>Here h(n) is heuristic cost, and h*(n) is the estimated cost. Hence heuristic cost should be less than or equal to the estimated cost.</strong></p>
<h2 class="h2">Pure Heuristic Search:</h2>
<p>Pure heuristic search is the simplest form of heuristic search algorithms. It expands nodes based on their heuristic value h(n). It maintains two lists, OPEN and CLOSED list. In the CLOSED list, it places those nodes which have already expanded and in the OPEN list, it places nodes which have yet not been expanded.</p>
<p>On each iteration, each node n with the lowest heuristic value is expanded and generates all its successors and n is placed to the closed list. The algorithm continues unit a goal state is found.</p>
<p>In the informed search we will discuss two main algorithms which are given below:</p>
<ul class="points">
<li><strong>Best First Search Algorithm(Greedy search)</strong></li>
<li><strong>A* Search Algorithm</strong></li>
</ul>
<h3 class="h2">1.) Best-first Search Algorithm (Greedy Search): </h3>
<p>Greedy best-first search algorithm always selects the path which appears best at that moment.  It is the combination of depth-first search and breadth-first search algorithms. It uses the heuristic function and search.  Best-first search allows us to take the advantages of both algorithms. With the help of best-first search, at each step, we can choose the most promising node. In the best first search algorithm, we expand the node which is closest to the goal node and the closest cost is estimated by heuristic function, i.e.</p>
<div class="codeblock"><textarea class="java" name="code">
    f(n)= g(n). 
</textarea></div>
<p>Were, h(n)= estimated cost from node n to the goal. </p>
<p>The greedy best first algorithm is implemented by the priority queue.</p>
<h3 class="h3">Best first search algorithm:</h3>
<ul class="points">
<li><strong>Step 1:</strong> Place the starting node into the OPEN list.</li>
<li><strong>Step 2:</strong> If the OPEN list is empty, Stop and return failure.</li>
<li><strong>Step 3:</strong> Remove the node n, from the OPEN list which has the lowest value of h(n), and places it in the CLOSED list.</li>
<li><strong>Step 4:</strong> Expand the node n, and generate the successors of node n.</li>
<li><strong>Step 5:</strong> Check each successor of node n, and find whether any node is a goal node or not. If any successor node is goal node, then return success and terminate the search, else proceed to Step 6.</li>
<li><strong>Step 6:</strong> For each successor node, algorithm checks for evaluation function f(n), and then check if the node has been in either OPEN or CLOSED list. If the node has not been in both list, then add it to the OPEN list.</li>
<li><strong>Step 7:</strong> Return to Step 2.</li>
</ul>
<h3 class="h3">Advantages:</h3>
<ul class="points">
<li>Best first search can switch between BFS and DFS by gaining the advantages of both the algorithms.</li>
<li>This algorithm is more efficient than BFS and DFS algorithms. </li>
</ul>
<h3 class="h3">Disadvantages:</h3>
<ul class="points">
<li>It can behave as an unguided depth-first search in the worst case scenario. </li>
<li>It can get stuck in a loop as DFS.</li>
<li>This algorithm is not optimal.</li>
</ul>
<h3 class="h3">Example: </h3>
<p>Consider the below search problem, and we will traverse it using greedy best-first search. At each iteration, each node is expanded using evaluation function f(n)=h(n) , which is given in the below table. </p>
<img alt="Informed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/informed-search-algorithms.png"/>
<p>In this search example, we are using two lists which are <strong>OPEN</strong> and <strong>CLOSED</strong> Lists. Following are the iteration for traversing the above example. </p>
<img alt="Informed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/informed-search-algorithms2.png"/>
<p><strong>Expand the nodes of S and put in the CLOSED list</strong></p>
<p><strong>Initialization:</strong> Open [A, B], Closed [S]</p>
<p><strong>Iteration 1:</strong> Open [A], Closed [S, B]</p>
<p><strong>Iteration 2:</strong> Open [E, F, A], Closed [S, B]<br/>
                  : Open [E, A], Closed [S, B, F]</p>
<p><strong>Iteration 3:</strong> Open [I, G, E, A], Closed [S, B, F]<br/>
                  : Open [I, E, A], Closed [S, B, F, G]</p>
<p>Hence the final solution path will be: <strong>S----&gt; B-----&gt;F----&gt; G</strong></p>
<p><strong>Time Complexity:</strong> The worst case time complexity of Greedy best first search is O(b<sup>m</sup>).</p>
<p><strong>Space Complexity:</strong> The worst case space complexity of Greedy best first search is O(b<sup>m</sup>). Where, m is the maximum depth of the search space.</p>
<p><strong>Complete:</strong> Greedy best-first search is also incomplete, even if the given state space is finite.</p>
<p><strong>Optimal:</strong> Greedy best first search algorithm is not optimal.</p>
<h3 class="h2">2.) A* Search Algorithm:</h3>
<p>A* search is the most commonly known form of best-first search. It uses heuristic function h(n), and cost to reach the node n from the start state g(n). It has combined features of UCS and greedy best-first search, by which it solve the problem efficiently. A* search algorithm finds the shortest path through the search space using the heuristic function. This search algorithm expands less search tree and provides optimal result faster. A* algorithm is similar to UCS except that it uses g(n)+h(n) instead of g(n).</p>
<p>In A* search algorithm, we use search heuristic as well as the cost to reach the node. Hence we can combine both costs as following, and this sum is called as a <strong>fitness number</strong>.</p>
<img alt="Informed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/informed-search-algorithms3.png"/>
<p class="n">At each point in the search space, only those node is expanded which have the lowest value of f(n), and the algorithm terminates when the goal node is found. </p>
<h3 class="h3">Algorithm of A* search:</h3>
<p><strong>Step1:</strong> Place the starting node in the OPEN list.</p>
<p><strong>Step 2:</strong> Check if the OPEN list is empty or not, if the list is empty then return failure and stops.</p>
<p><strong>Step 3:</strong> Select the node from the OPEN list which has the smallest value of evaluation function (g+h), if node n is goal node then return success and stop, otherwise</p>
<p><strong>Step 4:</strong> Expand node n and generate all of its successors, and put n into the closed list. For each successor n', check whether n' is already in the OPEN or CLOSED list, if not then compute evaluation function for n' and place into Open list.</p>
<p><strong>Step 5:</strong> Else if node n' is already in OPEN and CLOSED, then it should be attached to the back pointer which reflects the lowest g(n') value.</p>
<p><strong>Step 6:</strong> Return to <strong>Step 2</strong>.</p>
<h3 class="h3">Advantages:</h3>
<ul class="points">
<li>A* search algorithm is the best algorithm than other search algorithms.</li>
<li>A* search algorithm is optimal and complete.</li>
<li>This algorithm can solve very complex problems.</li>
</ul>
<h3 class="h3">Disadvantages:</h3>
<ul class="points">
<li>It does not always produce the shortest path as it mostly based on heuristics and approximation.</li>
<li>A* search algorithm has some complexity issues.</li>
<li>The main drawback of A* is memory requirement as it keeps all generated nodes in the memory, so it is not practical for various large-scale problems.</li>
</ul>
<h3 class="h3">Example:</h3>
In this example, we will traverse the given graph using the A* algorithm. The heuristic value of all states is given in the below table so we will calculate the f(n) of each state using the formula f(n)= g(n) + h(n), where g(n) is the cost to reach any node from start state.</td></tr></table></div></div></div></div></div></body></html>
Here we will use OPEN and CLOSED list.
<img alt="Informed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/informed-search-algorithms4.png"/>
<p><strong>Solution: </strong></p>
<img alt="Informed Search Algorithms" src="https://static.javatpoint.com/tutorial/ai/images/informed-search-algorithms5.png"/>
<p><strong>Initialization:</strong> {(S, 5)}</p>
<p><strong>Iteration1:</strong> {(S--&gt; A, 4), (S--&gt;G, 10)}</p>
<p><strong>Iteration2:</strong> {(S--&gt; A--&gt;C, 4), (S--&gt; A--&gt;B, 7), (S--&gt;G, 10)}</p>
<p><strong>Iteration3:</strong> {(S--&gt; A--&gt;C---&gt;G, 6), (S--&gt; A--&gt;C---&gt;D, 11), (S--&gt; A--&gt;B, 7), (S--&gt;G, 10)}</p>
<p><strong>Iteration 4</strong> will give the final result, as <strong>S---&gt;A---&gt;C---&gt;G</strong> it provides the optimal path with cost 6. </p>
<p><strong>Points to remember:</strong></p>
<ul class="points">
<li>A* algorithm returns the path which occurred first, and it does not search for all remaining paths.</li>
<li>The efficiency of A* algorithm depends on the quality of heuristic.</li>
<li>A* algorithm expands all nodes which satisfy the condition f(n) <c*, <="" c*="" cost="" is="" li="" of="" optimal="" path.="" solution="" the="" where="">
</c*,></li></ul>
<p><strong>Complete:</strong> A* algorithm is complete as long as:</p>
<ul class="points">
<li>Branching factor is finite.</li>
<li>Cost at every action is fixed.</li>
</ul>
<p><strong>Optimal:</strong> A* search algorithm is optimal if it follows below two conditions:</p>
<ul class="points">
<li><strong>Admissible:</strong> the first condition requires for optimality is that h(n) should be an admissible heuristic for A* tree search. An admissible heuristic is optimistic in nature. </li>
<li><strong>Consistency:</strong> Second required condition is consistency for only A* graph-search. </li>
</ul>
<p>If the heuristic function is admissible, then A* tree search will always find the least cost path.</p>
<p><strong>Time Complexity:</strong> The time complexity of A* search algorithm depends on heuristic function, and the number of nodes expanded is exponential to the depth of solution d. So the time complexity is O(b^d), where b is the branching factor.</p>
<p><strong>Space Complexity:</strong> The space complexity of A* search algorithm is <strong>O(b^d)</strong></p>
<h1 class="h1">Hill Climbing Algorithm in Artificial Intelligence</h1>
<ul class="points">
<li>Hill climbing algorithm is a local search algorithm which continuously moves in the direction of increasing elevation/value to find the peak of the mountain or best solution to the problem. It terminates when it reaches a peak value where no neighbor has a higher value.</li>
<li>Hill climbing algorithm is a technique which is used for optimizing the mathematical problems. One of the widely discussed examples of Hill climbing algorithm is Traveling-salesman Problem in which we need to minimize the distance traveled by the salesman.</li>
<li>It is also called greedy local search as it only looks to its good immediate neighbor state and not beyond that.</li>
<li>A node of hill climbing algorithm has two components which are state and value.</li>
<li>Hill Climbing is mostly used when a good heuristic is available.</li>
<li>In this algorithm, we don't need to maintain and handle the search tree or graph as it only keeps a single current state.</li>
</ul>
<h2 class="h2">Features of Hill Climbing:</h2>
<p>Following are some main features of Hill Climbing Algorithm:</p>
<ul class="points">
<li><strong>Generate and Test variant:</strong> Hill Climbing is the variant of Generate and Test method. The Generate and Test method produce feedback which helps to decide which direction to move in the search space.</li>
<li><strong>Greedy approach:</strong> Hill-climbing algorithm search moves in the direction which optimizes the cost.</li>
<li><strong>No backtracking:</strong> It does not backtrack the search space, as it does not remember the previous states.</li>
</ul>
<h2 class="h2">State-space Diagram for Hill Climbing: </h2>
<p>The state-space landscape is a graphical representation of the hill-climbing algorithm which is showing a graph between various states of algorithm and Objective function/Cost.</p>
<p>On Y-axis we have taken the function which can be an objective function or cost function, and state-space on the x-axis. If the function on Y-axis is cost then, the goal of search is to find the global minimum and local minimum. If the function of Y-axis is Objective function, then the goal of the search is to find the global maximum and local maximum.</p>
<img alt="Hill Climbing Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/hill-climbing-algorithm-in-ai.png"/>
<h2 class="h2">Different regions in the state space landscape:</h2>
<p><strong>Local Maximum:</strong> Local maximum is a state which is better than its neighbor states, but there is also another state which is higher than it.</p>
<p><strong>Global Maximum:</strong> Global maximum is the best possible state of state space landscape. It has the highest value of objective function.</p>
<p><strong>Current state:</strong> It is a state in a landscape diagram where an agent is currently present.</p>
<p><strong>Flat local maximum:</strong> It is a flat space in the landscape where all the neighbor states of current states have the same value.</p>
<p><strong>Shoulder:</strong> It is a plateau region which has an uphill edge.</p>
<h2 class="h2">Types of Hill Climbing Algorithm:</h2>
<ul class="points">
<li>Simple hill Climbing:</li>
<li>Steepest-Ascent hill-climbing:</li>
<li>Stochastic hill Climbing:</li>
</ul>
<h3 class="h3">1. Simple Hill Climbing: </h3>
<p>Simple hill climbing is the simplest way to implement a hill climbing algorithm. <strong>It only evaluates the neighbor node state at a time and selects the first one which optimizes current cost and set it as a current state</strong>. It only checks it's one successor state, and if it finds better than the current state, then move else be in the same state. This algorithm has the following features:</p>
<ul class="points">
<li>Less time consuming</li>
<li>Less optimal solution and the solution is not guaranteed</li>
</ul>
<h3 class="h4">Algorithm for Simple Hill Climbing:</h3>
<ul class="points">
<li><strong>Step 1:</strong> Evaluate the initial state, if it is goal state then return success and Stop.</li>
<li><strong>Step 2:</strong> Loop Until a solution is found or there is no new operator left to apply.</li>
<li><strong>Step 3:</strong> Select and apply an operator to the current state.</li>
<li><strong>Step 4:</strong> Check  new state:
<ol class="pointsa">
<li>If it is goal state, then return success and quit.</li>
<li>Else if it is better than the current state then assign new state as a current state.</li>
<li>Else if not better than the current state, then return to step2. </li>
</ol></li>
<li><strong>Step 5:</strong> Exit. </li>
</ul>
<h3 class="h3">2. Steepest-Ascent hill climbing:</h3>
<p>The steepest-Ascent algorithm is a variation of simple hill climbing algorithm. This algorithm examines all the neighboring nodes of the current state and selects one neighbor node which is closest to the goal state. This algorithm consumes more time as it searches for multiple neighbors</p>
<h3 class="h4">Algorithm for Steepest-Ascent hill climbing:</h3>
<ul class="points">
<li><strong>Step 1:</strong> Evaluate the initial state, if it is goal state then return success and stop, else make current state as initial state. </li>
<li><strong>Step 2:</strong> Loop until a solution is found or the current state does not change.
<ol class="pointsa">
<li>Let SUCC be a state such that any successor of the current state will be better than it.</li>
<li>For each operator that applies to the current state:
<ol type="I">
<li>Apply the new operator and generate a new state.</li>
<li>Evaluate the new state.</li>
<li>If it is goal state, then return it and quit, else compare it to the SUCC.</li>
<li>If it is better than SUCC, then set new state as SUCC.</li>
<li>If the SUCC is better than the current state, then set current state to SUCC.</li>
</ol></li>
</ol></li>
<li><strong>Step 5:</strong> Exit. </li>
</ul>
<h3 class="h3">3. Stochastic hill climbing: </h3>
<p>Stochastic hill climbing does not examine for all its neighbor before moving. Rather, this search algorithm selects one neighbor node at random and decides whether to choose it as a current state or examine another state. </p>
<h2 class="h2">Problems in Hill Climbing Algorithm:</h2>
<p><strong>1. Local Maximum:</strong> A local maximum is a peak state in the landscape which is better than each of its neighboring states, but there is another state also present which is higher than the local maximum. </p>
<p><strong>Solution:</strong> Backtracking technique can be a solution of the local maximum in state space landscape. Create a list of the promising path so that the algorithm can backtrack the search space and explore other paths as well. </p>
<img alt="Hill Climbing Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/hill-climbing-algorithm-in-ai2.png"/>
<p><strong>2. Plateau:</strong> A plateau is the flat area of the search space in which all the neighbor states of the current state contains the same value, because of this algorithm does not find any best direction to move. A hill-climbing search might be lost in the plateau area. </p>
<p><strong>Solution:</strong> The solution for the plateau is to take big steps or very little steps while searching, to solve the problem. Randomly select a state which is far away from the current state so it is possible that the algorithm could find non-plateau region.</p>
<img alt="Hill Climbing Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/hill-climbing-algorithm-in-ai3.png"/>
<p><strong>3. Ridges:</strong> A ridge is a special form of the local maximum. It has an area which is higher than its surrounding areas, but itself has a slope, and cannot be reached in a single move. </p>
<p><strong>Solution:</strong> With the use of bidirectional search, or by moving in different directions, we can improve this problem.</p>
<img alt="Hill Climbing Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/hill-climbing-algorithm-in-ai4.png"/>
<h3 class="h3">Simulated Annealing: </h3>
<p>A hill-climbing algorithm which never makes a move towards a lower value guaranteed to be incomplete because it can get stuck on a local maximum. And if algorithm applies a random walk, by moving a successor, then it may complete but not efficient. <strong>Simulated Annealing</strong> is an algorithm which yields both efficiency and completeness.</p>
<p>In mechanical term <strong>Annealing</strong> is a process of hardening a metal or glass to a high temperature then cooling gradually, so this allows the metal to reach a low-energy crystalline state. The same process is used in simulated annealing in which the algorithm picks a random move, instead of picking the best move. If the random move improves the state, then it follows the same path. Otherwise, the algorithm follows the path which has a probability of less than 1 or it moves downhill and chooses another path. </p>
<h1 class="h1">Means-Ends Analysis in Artificial Intelligence</h1>
<ul class="points">
<li>We have studied the strategies which can reason either in forward or backward, but a mixture of the two directions is appropriate for solving a complex and large problem. Such a mixed strategy, make it possible that first to solve the major part of a problem and then go back and solve the small problems arise during combining the big parts of the problem. Such a technique is called <strong>Means-Ends Analysis</strong>.</li>
<li>Means-Ends Analysis is problem-solving techniques used in Artificial intelligence for limiting search in AI programs.</li>
<li>It is a mixture of Backward and forward search technique.</li>
<li>The MEA technique was first introduced in 1961 by Allen Newell, and Herbert A. Simon in their problem-solving computer program, which was named as General Problem Solver (GPS).</li>
<li>The MEA analysis process centered on the evaluation of the difference between the current state and goal state.</li>
</ul>
<h2 class="h2">How means-ends analysis Works:</h2>
<p>The means-ends analysis process can be applied recursively for a problem. It is a strategy to control search in problem-solving. Following are the main Steps which describes the working of MEA technique for solving a problem.</p>
<ol class="pointsa">
<li>First, evaluate the difference between Initial State and final State.</li>
<li>Select the various operators which can be applied for each difference.</li>
<li>Apply the operator at each difference, which reduces the difference between the current state and goal state.</li>
</ol>
<h2 class="h2">Operator Subgoaling</h2>
<p> In the MEA process, we detect the differences between the current state and goal state. Once these differences occur, then we can apply an operator to reduce the differences. But sometimes it is possible that an operator cannot be applied to the current state. So we create the subproblem of the current state, in which operator can be applied, such type of backward chaining in which operators are selected, and then sub goals are set up to establish the preconditions of the operator is called <strong>Operator Subgoaling</strong>.</p>
<h2 class="h2">Algorithm for Means-Ends Analysis:</h2>
<p>Let's we take Current state as CURRENT and Goal State as GOAL, then following are the steps for the MEA algorithm. </p>
<ul class="points">
<li><strong>Step 1:</strong> Compare CURRENT to GOAL, if there are no differences between both then return Success and Exit. 
<li><strong>Step 2:</strong> Else, select the most significant difference and reduce it by doing the following steps until the success or failure occurs.
<ol class="pointsa">
<li>Select a new operator O which is applicable for the current difference, and if there is no such operator, then signal failure. </li>
<li>Attempt to apply operator O to CURRENT. Make a description of two states.<br/>
 i) O-Start, a state in which O?s preconditions are satisfied.<br/>
ii) O-Result, the state that would result if O were applied In O-start.</li>
<li>If<br/>
<strong>(First-Part &lt;------ MEA (CURRENT, O-START)</strong><br/>
And <br/>
<strong>(LAST-Part &lt;----- MEA (O-Result, GOAL)</strong>, are successful, then signal Success and return the result of combining FIRST-PART, O, and LAST-PART.</li>
</ol></li>
</li></ul>
<p>The above-discussed algorithm is more suitable for a simple problem and not adequate for solving complex problems. </p>
<h3 class="h3">Example of Mean-Ends Analysis:</h3>
<p>Let's take an example where we know the initial state and goal state as given below. In this problem, we need to get the goal state by finding differences between the initial state and goal state and applying operators. </p>
<img alt="Means-Ends Analysis in AI" src="https://static.javatpoint.com/tutorial/ai/images/means-ends-analysis-in-ai.png"/>
<h3 class="h3">Solution: </h3>
<p>To solve the above problem, we will first find the differences between initial states and goal states, and for each difference, we will generate a new state and will apply the operators. The operators we have for this problem are:</p>
<ul class="points">
<li><strong>Move</strong></li>
<li><strong>Delete</strong></li>
<li><strong>Expand</strong></li>
</ul>
<p><strong>1. Evaluating the initial state:</strong> In the first step, we will evaluate the initial state and will compare the initial and Goal state to find the differences between both states.</p>
<img alt="Means-Ends Analysis in AI" src="https://static.javatpoint.com/tutorial/ai/images/means-ends-analysis-in-ai2.png"/>
<p><strong>2. Applying Delete operator:</strong> As we can check the first difference is that in goal state there is no dot symbol which is present in the initial state, so, first we will apply the <strong>Delete operator</strong> to remove this dot.</p>
<img alt="Means-Ends Analysis in AI" src="https://static.javatpoint.com/tutorial/ai/images/means-ends-analysis-in-ai3.png"/>
<p><strong>3. Applying Move Operator:</strong> After applying the Delete operator, the new state occurs which we will again compare with goal state. After comparing these states, there is another difference that is the square is outside the circle, so, we will apply the <strong>Move Operator</strong>.</p>
<img alt="Means-Ends Analysis in AI" src="https://static.javatpoint.com/tutorial/ai/images/means-ends-analysis-in-ai4.png"/>
<p><strong>4. Applying Expand Operator:</strong> Now a new state is generated in the third step, and we will compare this state with the goal state. After comparing the states there is still one difference which is the size of the square, so, we will apply <strong>Expand operator</strong>, and finally, it will generate the goal state.</p>
<img alt="Means-Ends Analysis in AI" src="https://static.javatpoint.com/tutorial/ai/images/means-ends-analysis-in-ai5.png"/>
<h1 class="h1">Adversarial Search</h1>
<p><strong>Adversarial search is a search, where we examine the problem which arises when we try to plan ahead of the world and other agents are planning against us. </strong></p>
<ul class="points">
<li>In previous topics, we have studied the search strategies which are only associated with a single agent that aims to find the solution which often expressed in the form of a sequence of actions.</li>
<li>But, there might be some situations where more than one agent is searching for the solution in the same search space, and this situation usually occurs in game playing.</li>
<li>The environment with more than one agent is termed as <strong>multi-agent environment</strong>, in which each agent is an opponent of other agent and playing against each other. Each agent needs to consider the action of other agent and effect of that action on their performance.</li>
<li>So, <strong>Searches in which two or more players with conflicting goals are trying to explore the same search space for the solution, are called adversarial searches, often known as Games</strong>.</li>
<li>Games are modeled as a Search problem and heuristic evaluation function, and these are the two main factors which help to model and solve games in AI.</li>
</ul>
<h2 class="h2">Types of Games in AI:</h2>
<table class="alt">
<tr>
<th></th>
<th>Deterministic</th>
<th>Chance Moves</th>
</tr>
<tr>
<td><strong>Perfect information</strong></td>
<td>Chess, Checkers, go, Othello</td>
<td>Backgammon, monopoly</td>
</tr>
<tr>
<td><strong>Imperfect information</strong></td>
<td>Battleships, blind, tic-tac-toe</td>
<td>Bridge, poker, scrabble, nuclear war</td>
</tr>
</table>
<ul class="points">
<li><strong>Perfect information:</strong> A game with the perfect information is that in which agents can look into the complete board. Agents have all the information about the game, and they can see each other moves also. Examples are Chess, Checkers, Go, etc.</li>
<li><strong>Imperfect information:</strong> If in a game agents do not have all information about the game and not aware with what's going on, such type of games are called the game with imperfect information, such as tic-tac-toe, Battleship, blind, Bridge, etc.</li>
<li><strong>Deterministic games:</strong> Deterministic games are those games which follow a strict pattern and set of rules for the games, and there is no randomness associated with them. Examples are chess, Checkers, Go, tic-tac-toe, etc.</li>
<li><strong>Non-deterministic games:</strong> Non-deterministic are those games which have various unpredictable events and has a factor of chance or luck. This factor of chance or luck is introduced by either dice or cards. These are random, and each action response is not fixed. Such games are also called as stochastic games.<br/>
Example: Backgammon, Monopoly, Poker, etc. </li>
</ul>
<h4 class="n">Note: In this topic, we will discuss deterministic games, fully observable environment, zero-sum, and where each agent acts alternatively. </h4>
<h2 class="h2">Zero-Sum Game</h2>
<ul class="points">
<li>Zero-sum games are adversarial search which involves pure competition.</li>
<li>In Zero-sum game each agent's gain or loss of utility is exactly balanced by the losses or gains of utility of another agent.</li>
<li>One player of the game try to maximize one single value, while other player tries to minimize it.</li>
<li>Each move by one player in the game is called as ply.</li>
<li>Chess and tic-tac-toe are examples of a Zero-sum game.</li>
</ul>
<h3 class="h3">Zero-sum game: Embedded thinking</h3>
<p>The Zero-sum game involved embedded thinking in which one agent or player is trying to figure out: </p>
<ul class="points">
<li>What to do. </li>
<li>How to decide the move</li>
<li>Needs to think about his opponent as well</li>
<li>The opponent also thinks what to do</li>
</ul>
<p>Each of the players is trying to find out the response of his opponent to their actions. This requires embedded thinking or backward reasoning to solve the game problems in AI. </p>
<h3 class="h3">Formalization of the problem: </h3>
<p><strong>A game can be defined as a type of search in AI which can be formalized of the following elements:</strong></p>
<ul class="points">
<li><strong>Initial state:</strong> It specifies how the game is set up at the start.</li>
<li><strong>Player(s):</strong> It specifies which player has moved in the state space.</li>
<li><strong>Action(s):</strong> It returns the set of legal moves in state space.</li>
<li><strong>Result(s, a):</strong> It is the transition model, which specifies the result of moves in the state space.</li>
<li><strong>Terminal-Test(s):</strong> Terminal test is true if the game is over, else it is false at any case. The state where the game ends is called terminal states.</li>
<li><strong>Utility(s, p):</strong> A utility function gives the final numeric value for a game that ends in terminal states s for player p. It is also called payoff function. For Chess, the outcomes are a win, loss, or draw and its payoff values are +1, 0, ½. And for tic-tac-toe, utility values are +1, -1, and 0. </li>
</ul>
<h2 class="h2">Game tree: </h2>
<p>A game tree is a tree where nodes of the tree are the game states and Edges of the tree are the moves by players. Game tree involves initial state, actions function, and result Function. </p>
<p><strong>Example: Tic-Tac-Toe game tree:</strong></p>
<p>The following figure is showing part of the game-tree for tic-tac-toe game. Following are some key points of the game:</p>
<ul class="points">
<li>There are two players MAX and MIN.</li>
<li>Players have an alternate turn and start with MAX.</li>
<li>MAX maximizes the result of the game tree</li>
<li>MIN minimizes the result.</li>
</ul>
<img alt="Adversarial Search" src="https://static.javatpoint.com/tutorial/ai/images/ai-adversarial-search.png"/>
<p><strong>Example Explanation:</strong></p>
<ul class="points">
<li>From the initial state, MAX has 9 possible moves as he starts first. MAX place x and MIN place o, and both player plays alternatively until we reach a leaf node where one player has three in a row or all squares are filled.</li>
<li>Both players will compute each node, minimax, the minimax value which is the best achievable utility against an optimal adversary.</li>
<li>Suppose both the players are well aware of the tic-tac-toe and playing the best play. Each player is doing his best to prevent another one from winning. MIN is acting against Max in the game.</li>
<li>So in the game tree, we have a layer of Max, a layer of MIN, and each layer is called as <strong>Ply</strong>. Max place x, then MIN puts o to prevent Max from winning, and this game continues until the terminal node.</li>
<li>In this either MIN wins, MAX wins, or it's a draw. This game-tree is the whole search space of possibilities that MIN and MAX are playing tic-tac-toe and taking turns alternately.</li>
</ul>
<p>Hence adversarial Search for the minimax procedure works as follows:</p>
<ul class="points">
<li>It aims to find the optimal strategy for MAX to win the game. </li>
<li>It follows the approach of Depth-first search.</li>
<li>In the game tree, optimal leaf node could appear at any depth of the tree.</li>
<li>Propagate the minimax values up to the tree until the terminal node discovered.</li>
</ul>
<p>In a given game tree, the optimal strategy can be determined from the minimax value of each node, which can be written as MINIMAX(n). MAX prefer to move to a state of maximum value and MIN prefer to move to a state of minimum value then:</p>
<img alt="Adversarial Search" src="https://static.javatpoint.com/tutorial/ai/images/ai-adversarial-search2.png"/>
<h1 class="h1">Mini-Max Algorithm in Artificial Intelligence</h1>
<ul class="points">
<li>Mini-max algorithm is a recursive or backtracking algorithm which is used in decision-making and game theory. It provides an optimal move for the player assuming that opponent is also playing optimally.</li>
<li>Mini-Max algorithm uses recursion to search through the game-tree.</li>
<li>Min-Max algorithm is mostly used for game playing in AI. Such as Chess, Checkers, tic-tac-toe, go, and various tow-players game. This Algorithm computes the minimax decision for the current state.</li>
<li>In this algorithm two players play the game, one is called MAX and other is called MIN.</li>
<li>Both the players fight it as the opponent player gets the minimum benefit while they get the maximum benefit.</li>
<li>Both Players of the game are opponent of each other, where MAX will select the maximized value and MIN will select the minimized value.</li>
<li>The minimax algorithm performs a depth-first search algorithm for the exploration of the complete game tree.</li>
<li>The minimax algorithm proceeds all the way down to the terminal node of the tree, then backtrack the tree as the recursion. </li>
</ul>
<h2 class="h2">Pseudo-code for MinMax Algorithm:</h2>
<div class="codeblock"><textarea class="java" name="code">
function minimax(node, depth, maximizingPlayer) is
if depth ==0 or node is a terminal node then
return static evaluation of node

if MaximizingPlayer then      // for Maximizer Player
maxEva= -infinity          
 for each child of node do
 eva= minimax(child, depth-1, false)
maxEva= max(maxEva,eva)        //gives Maximum of the values
return maxEva

else                         // for Minimizer player
 minEva= +infinity 
 for each child of node do
 eva= minimax(child, depth-1, true)
 minEva= min(minEva, eva)         //gives minimum of the values
 return minEva
</textarea></div>
<p><strong>Initial call:</strong></p>
<p><strong>Minimax(node, 3, true)</strong></p>
<h2 class="h2">Working of Min-Max Algorithm:</h2>
<ul class="points">
<li>The working of the minimax algorithm can be easily described using an example. Below we have taken an example of game-tree which is representing the two-player game.</li>
<li>In this example, there are two players one is called Maximizer and other is called Minimizer.</li>
<li>Maximizer will try to get the Maximum possible score, and Minimizer will try to get the minimum possible score.</li>
<li>This algorithm applies DFS, so in this game-tree, we have to go all the way through the leaves to reach the terminal nodes. </li>
<li>At the terminal node, the terminal values are given so we will compare those value and backtrack the tree until the initial state occurs. Following are the main steps involved in solving the two-player game tree:</li>
</ul>
<p><strong>Step-1:</strong> In the first step, the algorithm generates the entire game-tree and apply the utility function to get the utility values for the terminal states. In the below tree diagram, let's take A is the initial state of the tree. Suppose maximizer takes first turn which has worst-case initial value =- infinity, and minimizer will take next turn which has worst-case initial value = +infinity.</p>
<img alt="Mini-Max Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/mini-max-algorithm-in-ai-step1.png"/>
<p><strong>Step 2:</strong> Now, first we find the utilities value for the Maximizer, its initial value is -∞, so we will compare each value in terminal state with initial value of Maximizer and determines the higher nodes values. It will find the maximum among the all.</p>
<ul class="points">
<li>For node D         max(-1,- -∞) =&gt; max(-1,4)= 4</li>
<li>For Node E         max(2, -∞) =&gt; max(2, 6)=  6</li>
<li>For Node F         max(-3, -∞) =&gt; max(-3,-5) = -3</li>
<li>For node G         max(0, -∞) = max(0, 7) = 7</li>
</ul>
<img alt="Mini-Max Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/mini-max-algorithm-in-ai-step2.png"/>
<p><strong>Step 3:</strong> In the next step, it's a turn for minimizer, so it will compare all nodes value with +∞, and will find the 3<sup>rd</sup> layer node values.</p>
<ul class="points">
<li>For node B= min(4,6) = 4</li>
<li>For node C= min (-3, 7) = -3</li>
</ul>
<img alt="Mini-Max Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/mini-max-algorithm-in-ai-step3.png"/>
<p><strong>Step 3:</strong> Now it's a turn for Maximizer, and it will again choose the maximum of all nodes value and find the maximum value for the root node. In this game tree, there are only 4 layers, hence we reach immediately to the root node, but in real games, there will be more than 4 layers.</p>
<ul class="points">
<li>For node A  max(4, -3)= 4</li>
</ul>
<img alt="Mini-Max Algorithm in AI" src="https://static.javatpoint.com/tutorial/ai/images/mini-max-algorithm-in-ai-step4.png"/>
<p>That was the complete workflow of the minimax two player game. </p>
<h2 class="h2">Properties of Mini-Max algorithm: </h2>
<ul class="points">
<li><strong>Complete-</strong> Min-Max algorithm is Complete. It will definitely find a solution (if exist), in the finite search tree.</li>
<li><strong>Optimal-</strong> Min-Max algorithm is optimal if both opponents are playing optimally.</li>
<li><strong>Time complexity-</strong> As it performs DFS for the game-tree, so the time complexity of Min-Max algorithm is <strong>O(b<sup>m</sup>)</strong>, where b is branching factor of the game-tree, and m is the maximum depth of the tree.</li>
<li><strong>Space Complexity-</strong> Space complexity of Mini-max algorithm is also similar to DFS which is <strong>O(bm)</strong>.</li>
</ul>
<h2 class="h2">Limitation of the minimax Algorithm:</h2>
<p>The main drawback of the minimax algorithm is that it gets really slow for complex games such as Chess, go, etc. This type of games has a huge branching factor, and the player has lots of choices to decide. This limitation of the minimax algorithm can be improved from <strong>alpha-beta pruning</strong> which we have discussed in the next topic. </p>
<h1 class="h1">Alpha-Beta Pruning</h1>
<ul class="points">
<li>Alpha-beta pruning is a modified version of the minimax algorithm. It is an optimization technique for the minimax algorithm. </li>
<li>As we have seen in the minimax search algorithm that the number of game states it has to examine are exponential in depth of the tree. Since we cannot eliminate the exponent, but we can cut it to half. Hence there is a technique by which without checking each node of the game tree we can compute the correct minimax decision, and this technique is called <strong>pruning</strong>. This involves two threshold parameter Alpha and beta for future expansion, so it is called <strong>alpha-beta pruning</strong>. It is also called as <strong>Alpha-Beta Algorithm</strong>.</li>
<li>Alpha-beta pruning can be applied at any depth of a tree, and sometimes it not only prune the tree leaves but also entire sub-tree.</li>
<li>The two-parameter can be defined as:
<ol class="pointsa">
<li><strong>Alpha:</strong> The best (highest-value) choice we have found so far at any point along the path of Maximizer. The initial value of alpha is <strong>-∞</strong>. </li>
<li><strong>Beta:</strong> The best (lowest-value) choice we have found so far at any point along the path of Minimizer. The initial value of beta is <strong>+∞</strong>.</li>
</ol></li>
<li>The Alpha-beta pruning to a standard minimax algorithm returns the same move as the standard algorithm does, but it removes all the nodes which are not really affecting the final decision but making algorithm slow. Hence by pruning these nodes, it makes the algorithm fast. </li>
</ul>
<h4 class="n">Note: To better understand this topic, kindly study the minimax algorithm. </h4>
<h2 class="h2">Condition for Alpha-beta pruning:</h2>
<p>The main condition which required for alpha-beta pruning is:</p>
<div class="codeblock"><textarea class="java" name="code">
α&gt;=β
</textarea></div>
<h2 class="h2">Key points about alpha-beta pruning:</h2>
<ul class="points">
<li>The Max player will only update the value of alpha.</li>
<li>The Min player will only update the value of beta.</li>
<li>While backtracking the tree, the node values will be passed to upper nodes instead of values of alpha and beta.</li>
<li>We will only pass the alpha, beta values to the child nodes.</li>
</ul>
<h2 class="h2">Pseudo-code for Alpha-beta Pruning: </h2>
<div class="codeblock"><textarea class="java" name="code">
function minimax(node, depth, alpha, beta, maximizingPlayer) is
if depth ==0 or node is a terminal node then
return static evaluation of node

if MaximizingPlayer then      // for Maximizer Player
   maxEva= -infinity          
   for each child of node do
   eva= minimax(child, depth-1, alpha, beta, False)
  maxEva= max(maxEva, eva) 
  alpha= max(alpha, maxEva)    
   if beta&lt;=alpha
 break
 return maxEva
  
else                         // for Minimizer player
   minEva= +infinity 
   for each child of node do
   eva= minimax(child, depth-1, alpha, beta, true)
   minEva= min(minEva, eva) 
   beta= min(beta, eva)
    if beta&lt;=alpha
  break        
 return minEva
</textarea></div>
<h2 class="h2">Working of Alpha-Beta Pruning:</h2>
<p>Let's take an example of two-player search tree to understand the working of Alpha-beta pruning</p>
<p><strong>Step 1:</strong> At the first step the, Max player will start first move from node A where α= -∞ and β= +∞, these value of alpha and beta passed down to node B where again α= -∞ and β= +∞, and Node B passes the same value to its child D.</p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step1.png"/>
<p><strong>Step 2:</strong> At Node D, the value of α will be calculated as its turn for Max. The value of α is compared with firstly 2 and then 3, and the max (2, 3) = 3 will be the value of α at node D and node value will also 3.</p>
<p><strong>Step 3:</strong> Now algorithm backtrack to node B, where the value of β will change as this is a turn of Min, Now β= +∞, will compare with the available subsequent nodes value, i.e. min (∞, 3) = 3, hence at node B now α= -∞, and β= 3.</p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step3.png"/>
<p>In the next step, algorithm traverse the next successor of Node B which is node E, and the values of α= -∞, and β= 3 will also be passed.</p>
<p><strong>Step 4:</strong> At node E, Max will take its turn, and the value of alpha will change. The current value of alpha will be compared with 5, so max (-∞, 5) = 5, hence at node E α= 5 and β= 3, where α&gt;=β, so the right successor of E will be pruned, and algorithm will not traverse it, and the value at node E will be 5. </p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step4.png"/>
<p><strong>Step 5:</strong> At next step, algorithm again backtrack the tree, from node B to node A. At node A, the value of alpha will be changed the maximum available value is 3 as max (-∞, 3)= 3, and β= +∞,  these two values now passes to right successor of A which is Node C.</p>
<p>At node C, α=3 and β= +∞, and the same values will be passed on to node F.</p>
<p><strong>Step 6:</strong> At node F, again the value of α will be compared with left child which is 0, and max(3,0)= 3, and then compared with right child which is 1, and max(3,1)= 3 still α remains 3, but the node value of F will become 1. </p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step6.png"/>
<p><strong>Step 7:</strong> Node F returns the node value 1 to node C, at C α= 3 and β= +∞, here the value of beta will be changed, it will compare with 1 so min (∞, 1) = 1. Now at C, α=3 and β= 1, and again it satisfies the condition α&gt;=β, so the next child of C which is G will be pruned, and the algorithm will not compute the entire sub-tree G.</p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step7.png"/>
<p><strong>Step 8:</strong> C now returns the value of 1 to A here the best value for A is max (3, 1) = 3. Following is the final game tree which is the showing the nodes which are computed and nodes which has never computed. Hence the optimal value for the maximizer is 3 for this example. </p>
<img alt="Alpha-Beta Pruning" src="https://static.javatpoint.com/tutorial/ai/images/alpha-beta-pruning-step8.png"/>
<h2 class="h2">Move Ordering in Alpha-Beta pruning: </h2>
<p>The effectiveness of alpha-beta pruning is highly dependent on the order in which each node is examined. Move order is an important aspect of alpha-beta pruning.</p>
<p>It can be of two types:</p>
<ul class="points">
<li><strong>Worst ordering:</strong> In some cases, alpha-beta pruning algorithm does not prune any of the leaves of the tree, and works exactly as minimax algorithm. In this case, it also consumes more time because of alpha-beta factors, such a move of pruning is called worst ordering. In this case, the best move occurs on the right side of the tree. The time complexity for such an order is O(b<sup>m</sup>).</li>
<li><strong>Ideal ordering:</strong> The ideal ordering for alpha-beta pruning occurs when lots of pruning happens in the tree, and best moves occur at the left side of the tree. We apply DFS hence it first search left of the tree and go deep twice as minimax algorithm in the same amount of time. Complexity in ideal ordering is O(b<sup>m/2</sup>).</li>
</ul>
<h2 class="h2">Rules to find good ordering: </h2>
<p>Following are some rules to find good ordering in alpha-beta pruning:</p>
<ul class="points">
<li>Occur the best move from the shallowest node.</li>
<li>Order the nodes in the tree such that the best nodes are checked first. </li>
<li>Use domain knowledge while finding the best move. Ex: for Chess, try order: captures first, then threats, then forward moves, backward moves.</li>
<li>We can bookkeep the states, as there is a possibility that states may repeat.</li>
</ul>
<h1 class="h1">Knowledge-Based Agent in Artificial intelligence</h1>
<ul class="points">
<li>An intelligent agent needs <strong>knowledge</strong> about the real world for taking decisions and <strong>reasoning</strong> to act efficiently. </li>
<li>Knowledge-based agents are those agents who have the capability of <strong>maintaining an internal state of knowledge, reason over that knowledge, update their knowledge after observations and take actions. These agents can represent the world with some formal representation and act intelligently</strong>.</li>
<li>Knowledge-based agents are composed of two main parts:
<ul class="points">
<li><strong>Knowledge-base and</strong></li>
<li><strong>Inference system</strong>.</li>
</ul></li>
</ul>
<p>A knowledge-based agent must able to do the following:</p>
<ul class="points">
<li>An agent should be able to represent states, actions, etc.</li>
<li>An agent Should be able to incorporate new percepts</li>
<li>An agent can update the internal representation of the world</li>
<li>An agent can deduce the internal representation of the world</li>
<li>An agent can deduce appropriate actions.</li>
</ul>
<h2 class="h2">The architecture of knowledge-based agent: </h2>
<img alt="Knowledge-Based Agent in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/knowledge-based-agent-in-ai.png"/>
<p>The above diagram is representing a generalized architecture for a knowledge-based agent. The knowledge-based agent (KBA) take input from the environment by perceiving the environment. The input is taken by the inference engine of the agent and which also communicate with KB to decide as per the knowledge store in KB. The learning element of KBA regularly updates the KB by learning new knowledge.</p>
<p><strong>Knowledge base:</strong> Knowledge-base is a central component of a knowledge-based agent, it is also known as KB. It is a collection of sentences (here 'sentence' is a technical term and it is not identical to sentence in English). These sentences are expressed in a language which is called a knowledge representation language. The Knowledge-base of KBA stores fact about the world. </p>
<h2 class="h3">Why use a knowledge base?</h2>
<p>Knowledge-base is required for updating knowledge for an agent to learn with experiences and take action as per the knowledge. </p>
<h2 class="h2">Inference system</h2>
<p>Inference means deriving new sentences from old. Inference system allows us to add a new sentence to the knowledge base. A sentence is a proposition about the world. Inference system applies logical rules to the KB to deduce new information.</p>
<p>Inference system generates new facts so that an agent can update the KB. An inference system works mainly in two rules which are given as:</p>
<ul class="points">
<li><strong>Forward chaining </strong></li>
<li><strong>Backward chaining</strong></li>
</ul>
<h2 class="h2">Operations Performed by KBA</h2>
<p><strong>Following are three operations which are performed by KBA in order to show the intelligent behavior:</strong></p>
<ol class="points">
<li><strong>TELL:</strong> This operation tells the knowledge base what it perceives from the environment.</li>
<li><strong>ASK:</strong> This operation asks the knowledge base what action it should perform.</li>
<li><strong>Perform:</strong> It performs the selected action.</li>
</ol>
<h2 class="h2">A generic knowledge-based agent:</h2>
<p>Following is the structure outline of a generic knowledge-based agents program:</p>
<div class="codeblock"><textarea class="java" name="code">
function KB-AGENT(percept):
persistent: KB, a knowledge base 
          t, a counter, initially 0, indicating time 
TELL(KB, MAKE-PERCEPT-SENTENCE(percept, t)) 
Action = ASK(KB, MAKE-ACTION-QUERY(t)) 
TELL(KB, MAKE-ACTION-SENTENCE(action, t))
 t = t + 1
 return action 
</textarea></div>
<p>The knowledge-based agent takes percept as input and returns an action as output. The agent maintains the knowledge base, KB, and it initially has some background knowledge of the real world. It also has a counter to indicate the time for the whole process, and this counter is initialized with zero.</p>
<p>Each time when the function is called, it performs its three operations:</p>
<ul class="points">
<li>Firstly it TELLs the KB what it perceives.</li>
<li>Secondly, it asks KB what action it should take</li>
<li>Third agent program TELLS the KB that which action was chosen.</li>
</ul>
<p>The MAKE-PERCEPT-SENTENCE generates a sentence as setting that the agent perceived the given percept at the given time.</p>
<p>The MAKE-ACTION-QUERY generates a sentence to ask which action should be done at the current time.</p>
<p>MAKE-ACTION-SENTENCE generates a sentence which asserts that the chosen action was executed. </p>
<h2 class="h2">Various levels of knowledge-based agent:</h2>
<p>A knowledge-based agent can be viewed at different levels which are given below:</p>
<h3 class="h3">1. Knowledge level</h3>
<p>Knowledge level is the first level of knowledge-based agent, and in this level, we need to specify what the agent knows, and what the agent goals are. With these specifications, we can fix its behavior. For example, suppose an automated taxi agent needs to go from a station A to station B, and he knows the way from A to B, so this comes at the knowledge level.</p>
<h3 class="h3">2. Logical level:</h3>
<p>At this level, we understand that how the knowledge representation of knowledge is stored. At this level, sentences are encoded into different logics. At the logical level, an encoding of knowledge into logical sentences occurs. At the logical level we can expect to the automated taxi agent to reach to the destination B.</p>
<h3 class="h3">3. Implementation level:</h3>
<p>This is the physical representation of logic and knowledge. At the implementation level agent perform actions as per logical and knowledge level. At this level, an automated taxi agent actually implement his knowledge and logic so that he can reach to the destination.</p>
<h2 class="h2">Approaches to designing a knowledge-based agent:</h2>
<p>There are mainly two approaches to build a knowledge-based agent:</p>
<ol class="points">
<li><strong>1. Declarative approach:</strong> We can create a knowledge-based agent by initializing with an empty knowledge base and telling the agent all the sentences with which we want to start with. This approach is called Declarative approach.</li>
<li><strong>2. Procedural approach:</strong> In the procedural approach, we directly encode desired behavior as a program code. Which means we just need to write a program that already encodes the desired behavior or agent.</li>
</ol>
<p>However, in the real world, a successful agent can be built by combining both declarative and procedural approaches, and declarative knowledge can often be compiled into more efficient procedural code. </p>
<h1 class="h1">What is knowledge representation?</h1>
<p>Humans are best at understanding, reasoning, and interpreting knowledge. Human knows things, which is knowledge and as per their knowledge they perform various actions in the real world. <strong>But how machines do all these things comes under knowledge representation and reasoning</strong>. Hence we can describe Knowledge representation as following:</p>
<ul class="points">
<li>Knowledge representation and reasoning (KR, KRR) is the part of Artificial intelligence which concerned with AI agents thinking and how thinking contributes to intelligent behavior of agents. </li>
<li>It is responsible for representing information about the real world so that a computer can understand and can utilize this knowledge to solve the complex real world problems such as diagnosis a medical condition or communicating with humans in natural language.</li>
<li>It is also a way which describes how we can represent knowledge in artificial intelligence. Knowledge representation is not just storing data into some database, but it also enables an intelligent machine to learn from that knowledge and experiences so that it can behave intelligently like a human.</li>
</ul>
<h2 class="h2">What to Represent: </h2>
<p>Following are the kind of knowledge which needs to be represented in AI systems:</p>
<ul class="points">
<li><strong>Object:</strong> All the facts about objects in our world domain. E.g., Guitars contains strings, trumpets are brass instruments. 
<li><strong>Events:</strong> Events are the actions which occur in our world.</li>
<li><strong>Performance:</strong> It describe behavior which involves knowledge about how to do things.</li>
<li><strong>Meta-knowledge:</strong> It is knowledge about what we know.</li>
<li><strong>Facts:</strong> Facts are the truths about the real world and what we represent.</li>
<li><strong>Knowledge-Base:</strong> The central component of the knowledge-based agents is the knowledge base. It is represented as KB. The Knowledgebase is a group of the Sentences (Here, sentences are used as a technical term and not identical with the English language).</li>
</li></ul>
<p><strong>Knowledge:</strong> Knowledge is awareness or familiarity gained by experiences of facts, data, and situations. Following are the types of knowledge in artificial intelligence:</p>
<h2 class="h2">Types of knowledge</h2>
<p>Following are the various types of knowledge: </p>
<img alt="Knowledge Representation in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/knowledge-representation-in-ai.png"/>
<p><strong>1. Declarative Knowledge:</strong></p>
<ul class="points">
<li>Declarative knowledge is to know about something.</li>
<li>It includes concepts, facts, and objects.</li>
<li>It is also called descriptive knowledge and expressed in declarativesentences.</li>
<li>It is simpler than procedural language.</li>
</ul>
<p><strong>2. Procedural Knowledge</strong></p>
<ul class="points">
<li>It is also known as imperative knowledge.</li>
<li>Procedural knowledge is a type of knowledge which is responsible for knowing how to do something.</li>
<li>It can be directly applied to any task.</li>
<li>It includes rules, strategies, procedures, agendas, etc.</li>
<li>Procedural knowledge depends on the task on which it can be applied.</li>
</ul>
<p><strong>3. Meta-knowledge:</strong></p>
<ul class="points">
<li>Knowledge about the other types of knowledge is called Meta-knowledge.</li>
</ul>
<p><strong>4. Heuristic knowledge:</strong></p>
<ul class="points">
<li>Heuristic knowledge is representing knowledge of some experts in a filed or subject.</li>
<li>Heuristic knowledge is rules of thumb based on previous experiences, awareness of approaches, and which are good to work but not guaranteed.</li>
</ul>
<p><strong>5. Structural knowledge:</strong></p>
<ul class="points">
<li>Structural knowledge is basic knowledge to problem-solving.</li>
<li>It describes relationships between various concepts such as kind of, part of, and grouping of something.</li>
<li>It describes the relationship that exists between concepts or objects.</li>
</ul>
<h2 class="h2">The relation between knowledge and intelligence:</h2>
<p>Knowledge of real-worlds plays a vital role in intelligence and same for creating artificial intelligence. Knowledge plays an important role in demonstrating intelligent behavior in AI agents. An agent is only able to accurately act on some input when he has some knowledge or experience about that input.</p>
<p>Let's suppose if you met some person who is speaking in a language which you don't know, then how you will able to act on that. The same thing applies to the intelligent behavior of the agents. </p>
<p>As we can see in below diagram, there is one decision maker which act by sensing the environment and using knowledge. But if the knowledge part will not present then, it cannot display intelligent behavior. </p>
<img alt="Knowledge Representation in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/knowledge-representation-in-ai2.png"/>
<h2 class="h2">AI knowledge cycle:</h2>
<p>An Artificial intelligence system has the following components for displaying intelligent behavior: </p>
<ul class="points">
<li>Perception</li>
<li>Learning</li>
<li>Knowledge Representation and Reasoning</li>
<li>Planning</li>
<li>Execution</li>
</ul>
<img alt="Knowledge Representation in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/knowledge-representation-in-ai3.png"/>
<p>The above diagram is showing how an AI system can interact with the real world and what components help it to show intelligence. AI system has Perception component by which it retrieves information from its environment. It can be visual, audio or another form of sensory input. The learning component is responsible for learning from data captured by Perception comportment. In the complete cycle, the main components are knowledge representation and Reasoning. These two components are involved in showing the intelligence in machine-like humans. These two components are independent with each other but also coupled together. The planning and execution depend on analysis of Knowledge representation and reasoning. </p>
<h2 class="h2">Approaches to knowledge representation:</h2>
<p>There are mainly four approaches to knowledge representation, which are givenbelow:</p>
<h3 class="h3">1. Simple relational knowledge:</h3>
<ul class="points">
<li>It is the simplest way of storing facts which uses the relational method, and each fact about a set of the object is set out systematically in columns.</li>
<li>This approach of knowledge representation is famous in database systems where the relationship between different entities is represented.</li>
<li>This approach has little opportunity for inference. </li>
</ul>
<p><strong>Example: The following is the simple relational knowledge representation. </strong></p>
<table class="alt">
<tr>
<th>Player</th>
<th>Weight</th>
<th>Age</th>
</tr>
<tr>
<td>Player1</td>
<td>65</td>
<td>23</td>
</tr>
<tr>
<td>Player2</td>
<td>58</td>
<td>18</td>
</tr>
<tr>
<td>Player3</td>
<td>75</td>
<td>24</td>
</tr>
</table>
<h3 class="h3">2. Inheritable knowledge:</h3>
<ul class="points">
<li>In the inheritable knowledge approach, all data must be stored into a hierarchy of classes.</li>
<li>All classes should be arranged in a generalized form or a hierarchal manner.</li>
<li>In this approach, we apply inheritance property.</li>
<li>Elements inherit values from other members of a class.</li>
<li>This approach contains inheritable knowledge which shows a relation between instance and class, and it is called instance relation.</li>
<li>Every individual frame can represent the collection of attributes and its value.</li>
<li>In this approach, objects and values are represented in Boxed nodes.</li>
<li>We use Arrows which point from objects to their values.</li>
<li><strong>Example: </strong></li>
</ul>
<img alt="Knowledge Representation in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/knowledge-representation-in-ai4.png"/>
<h3 class="h3">3. Inferential knowledge:</h3>
<ul class="points">
<li>Inferential knowledge approach represents knowledge in the form of formal logics.</li>
<li>This approach can be used to derive more facts.</li>
<li>It guaranteed correctness.</li>
<li><strong>Example:</strong> Let's suppose there are two statements:
<ol class="pointsa">
<li>Marcus is a man</li>
<li>All men are mortal<br/>
Then it can represent as;<br/><br/>
<strong>man(Marcus)<br/>
∀x = man (x) ----------&gt; mortal (x)s</strong></li>
</ol></li>
</ul>
<h3 class="h3">4. Procedural knowledge:</h3>
<ul class="points">
<li>Procedural knowledge approach uses small programs and codes which describes how to do specific things, and how to proceed.</li>
<li>In this approach, one important rule is used which is <strong>If-Then rule</strong>.</li>
<li>In this knowledge, we can use various coding languages such as <strong>LISP language</strong> and <strong>Prolog language</strong>.</li>
<li>We can easily represent heuristic or domain-specific knowledge using this approach.</li>
<li>But it is not necessary that we can represent all cases in this approach. </li>
</ul>
<h2 class="h2">Requirements for knowledge Representation system:</h2>
<p>A good knowledge representation system must possess the following properties.</p>
<ol class="points">
<li><strong>1. Representational Accuracy:</strong><br/>
KR system should have the ability to represent all kind of required knowledge.</li>
<li><strong>2. Inferential Adequacy:</strong><br/>
KR system should have ability to manipulate the representational structures to produce new knowledge corresponding to existing structure.</li>
<li><strong>3. Inferential Efficiency:</strong><br/>
The ability to direct the inferential knowledge mechanism into the most productive directions by storing appropriate guides.</li>
<li><strong>4. Acquisitional efficiency-</strong> The ability to acquire the new knowledge easily using automatic methods. </li>
</ol>
<h1 class="h1">Techniques of knowledge representation</h1>
<p>There are mainly four ways of knowledge representation which are given as follows:</p>
<ol class="points">
<li>Logical Representation</li>
<li>Semantic Network Representation</li>
<li>Frame Representation</li>
<li>Production Rules</li>
</ol>
<img alt="Techniques of knowledge representation" src="https://static.javatpoint.com/tutorial/ai/images/ai-techniques-of-knowledge-representation.png"/>
<h2 class="h2">1. Logical Representation</h2>
<p>Logical representation is a language with some concrete rules which deals with propositions and has no ambiguity in representation. Logical representation means drawing a conclusion based on various conditions. This representation lays down some important communication rules. It consists of precisely defined syntax and semantics which supports the sound inference. Each sentence can be translated into logics using syntax and semantics. </p>
<h3 class="h3">Syntax: </h3>
<ul class="points">
<li>Syntaxes are the rules which decide how we can construct legal sentences in the logic.</li>
<li>It determines which symbol we can use in knowledge representation.</li>
<li>How to write those symbols.</li>
</ul>
<h3 class="h3">Semantics:</h3>
<ul class="points">
<li>Semantics are the rules by which we can interpret the sentence in the logic. </li>
<li>Semantic also involves assigning a meaning to each sentence. </li>
</ul>
<p>Logical representation can be categorised into mainly two logics:</p>
<ol class="pointsa">
<li>Propositional Logics</li>
<li>Predicate logics</li>
</ol>
<h4 class="n">Note: We will discuss Prepositional Logics and Predicate logics in later chapters. </h4>
<h3 class="h3">Advantages of logical representation: </h3>
<ol class="points">
<li>Logical representation enables us to do logical reasoning.</li>
<li>Logical representation is the basis for the programming languages.</li>
</ol>
<h3 class="h3">Disadvantages of logical Representation: </h3>
<ol class="points">
<li>Logical representations have some restrictions and are challenging to work with.</li>
<li>Logical representation technique may not be very natural, and inference may not be so efficient. </li>
</ol>
<h4 class="n">Note: Do not be confused with logical representation and logical reasoning as logical representation is a representation language and reasoning is a process of thinking logically.</h4>
<h2 class="h2">2. Semantic Network Representation</h2>
<p>Semantic networks are alternative of predicate logic for knowledge representation. In Semantic networks, we can represent our knowledge in the form of graphical networks. This network consists of nodes representing objects and arcs which describe the relationship between those objects. Semantic networks can categorize the object in different forms and can also link those objects. Semantic networks are easy to understand and can be easily extended. </p>
<p>This representation consist of mainly two types of relations:</p>
<ol class="pointsa">
<li>IS-A relation (Inheritance)</li>
<li>Kind-of-relation</li>
</ol>
<p><strong>Example:</strong> Following are some statements which we need to represent in the form of nodes and arcs.</p>
<h3 class="h3">Statements:</h3>
<ol class="pointsa">
<li>Jerry is a cat.</li>
<li>Jerry is a mammal</li>
<li>Jerry is owned by Priya. </li>
<li>Jerry is brown colored.</li>
<li>All Mammals are animal.</li>
</ol>
<img alt="Techniques of knowledge representation" src="https://static.javatpoint.com/tutorial/ai/images/ai-techniques-of-knowledge-representation2.png"/>
<p>In the above diagram, we have represented the different type of knowledge in the form of nodes and arcs. Each object is connected with another object by some relation. </p>
<h3 class="h3">Drawbacks in Semantic representation:</h3>
<ol class="points">
<li>Semantic networks take more computational time at runtime as we need to traverse the complete network tree to answer some questions. It might be possible in the worst case scenario that after traversing the entire tree, we find that the solution does not exist in this network.</li>
<li>Semantic networks try to model human-like memory (Which has 1015 neurons and links) to store the information, but in practice, it is not possible to build such a vast semantic network.</li>
<li>These types of representations are inadequate as they do not have any equivalent quantifier, e.g., for all, for some, none, etc.</li>
<li>Semantic networks do not have any standard definition for the link names.</li>
<li>These networks are not intelligent and depend on the creator of the system.</li>
</ol>
<h3 class="h3">Advantages of Semantic network:</h3>
<ol class="points">
<li>Semantic networks are a natural representation of knowledge.</li>
<li>Semantic networks convey meaning in a transparent manner.</li>
<li>These networks are simple and easily understandable.</li>
</ol>
<h2 class="h2">3. Frame Representation</h2>
<p>A frame is a record like structure which consists of a collection of attributes and its values to describe an entity in the world. Frames are the AI data structure which divides knowledge into substructures by representing stereotypes situations. It consists of a collection of slots and slot values. These slots may be of any type and sizes. Slots have names and values which are called facets. </p>
<p><strong>Facets:</strong> The various aspects of a slot is known as <strong>Facets</strong>. Facets are features of frames which enable us to put constraints on the frames. Example: IF-NEEDED facts are called when data of any particular slot is needed. A frame may consist of any number of slots, and a slot may include any number of facets and facets may have any number of values. A frame is also known as <strong>slot-filter knowledge representation</strong> in artificial intelligence. </p>
<p>Frames are derived from semantic networks and later evolved into our modern-day classes and objects. A single frame is not much useful. Frames system consist of a collection of frames which are connected. In the frame, knowledge about an object or event can be stored together in the knowledge base.  The frame is a type of technology which is widely used in various applications including Natural language processing and machine visions.</p>
<h3 class="h3">Example: 1</h3>
<p>Let's take an example of a frame for a book</p>
<table class="alt">
<tr>
<th>Slots</th>
<th>Filters</th>
</tr>
<tr>
<td><strong>Title</strong></td>
<td>Artificial Intelligence</td>
</tr>
<tr>
<td><strong>Genre</strong></td>
<td>Computer Science</td>
</tr>
<tr>
<td><strong>Author</strong></td>
<td>Peter Norvig</td>
</tr>
<tr>
<td><strong>Edition</strong></td>
<td>Third Edition</td>
</tr>
<tr>
<td><strong>Year</strong></td>
<td>1996</td>
</tr>
<tr>
<td><strong>Page</strong></td>
<td>1152</td>
</tr>
</table>
<h3 class="h3">Example 2: </h3>
<p>Let's suppose we are taking an entity, Peter. Peter is an engineer as a profession, and his age is 25, he lives in city London, and the country is England. So following is the frame representation for this:</p>
<table class="alt">
<tr>
<th>Slots</th>
<th>Filter</th>
</tr>
<tr>
<td><strong>Name</strong></td>
<td>Peter</td>
</tr>
<tr>
<td><strong>Profession</strong></td>
<td>Doctor</td>
</tr>
<tr>
<td><strong>Age</strong></td>
<td>25</td>
</tr>
<tr>
<td><strong>Marital status</strong></td>
<td>Single</td>
</tr>
<tr>
<td><strong>Weight</strong></td>
<td>78</td>
</tr>
</table>
<h3 class="h3">Advantages of frame representation:</h3>
<ol class="points">
<li>The frame knowledge representation makes the programming easier by grouping the related data.</li>
<li>The frame representation is comparably flexible and used by many applications in AI.</li>
<li>It is very easy to add slots for new attribute and relations.</li>
<li>It is easy to include default data and to search for missing values.</li>
<li>Frame representation is easy to understand and visualize.</li>
</ol>
<h3 class="h3">Disadvantages of frame representation: </h3>
<ol class="points">
<li>In frame system inference mechanism is not be easily processed.</li>
<li>Inference mechanism cannot be smoothly proceeded by frame representation.</li>
<li>Frame representation has a much generalized approach.</li>
</ol>
<h2 class="h2">4. Production Rules</h2>
<p>Production rules system consist of (<strong>condition, action</strong>) pairs which mean, "If condition then action". It has mainly three parts:</p>
<ul class="points">
<li>The set of production rules</li>
<li>Working Memory</li>
<li>The recognize-act-cycle</li>
</ul>
<p>In production rules agent checks for the condition and if the condition exists then production rule fires and corresponding action is carried out. The condition part of the rule determines which rule may be applied to a problem. And the action part carries out the associated problem-solving steps. This complete process is called a recognize-act cycle.</p>
<p>The working memory contains the description of the current state of problems-solving and rule can write knowledge to the working memory. This knowledge match and may fire other rules.</p>
<p>If there is a new situation (state) generates, then multiple production rules will be fired together, this is called conflict set. In this situation, the agent needs to select a rule from these sets, and it is called a conflict resolution.</p>
<h3 class="h3">Example: </h3>
<ul class="points">
<li><strong>IF (at bus stop AND bus arrives) THEN action (get into the bus)</strong></li>
<li><strong>IF (on the bus AND paid AND empty seat) THEN action (sit down).</strong></li>
<li><strong>IF (on bus AND unpaid) THEN action (pay charges).</strong></li>
<li><strong>IF (bus arrives at destination) THEN action (get down from the bus). </strong></li>
</ul>
<h3 class="h3">Advantages of Production rule:</h3>
<ol class="points">
<li>The production rules are expressed in natural language.</li>
<li>The production rules are highly modular, so we can easily remove, add or modify an individual rule.</li>
</ol>
<h3 class="h3">Disadvantages of Production rule: </h3>
<ol class="points">
<li>Production rule system does not exhibit any learning capabilities, as it does not store the result of the problem for the future uses.</li>
<li>During the execution of the program, many rules may be active hence rule-based production systems are inefficient.</li>
</ol>
<h1 class="h1">Propositional logic in Artificial intelligence</h1>
<p>Propositional logic (PL) is the simplest form of logic where all the statements are made by propositions. A proposition is a declarative statement which is either true or false. It is a technique of knowledge representation in logical and mathematical form.</p>
<h3 class="h3">Example:</h3>
<div class="codeblock"><textarea class="java" name="code">
a) It is Sunday.
b) The Sun rises from West (False proposition)
c) 3+3= 7(False proposition)
d) 5 is a prime number. 
</textarea></div>
<p><strong>Following are some basic facts about propositional logic:</strong></p>
<ul class="points">
<li>Propositional logic is also called Boolean logic as it works on 0 and 1.</li>
<li>In propositional logic, we use symbolic variables to represent the logic, and we can use any symbol for a representing a proposition, such A, B, C, P, Q, R, etc.</li>
<li>Propositions can be either true or false, but it cannot be both.</li>
<li>Propositional logic consists of an object, relations or function, and <strong>logical connectives</strong>.</li>
<li>These connectives are also called logical operators.</li>
<li>The propositions and connectives are the basic elements of the propositional logic.</li>
<li>Connectives can be said as a logical operator which connects two sentences.</li>
<li>A proposition formula which is always true is called <strong>tautology</strong>, and it is also called a valid sentence.</li>
<li>A proposition formula which is always false is called <strong>Contradiction</strong>.</li>
<li>A proposition formula which has both true and false values is called  </li>
<li>Statements which are questions, commands, or opinions are not propositions such as "<strong>Where is Rohini</strong>", "<strong>How are you</strong>", "<strong>What is your name</strong>", are not propositions. </li>
</ul>
<h3 class="h3">Syntax of propositional logic:</h3>
<p>The syntax of propositional logic defines the allowable sentences for the knowledge representation. There are two types of Propositions:</p>
<ol class="pointsa">
<li><strong>Atomic Propositions</strong></li>
<li><strong>Compound propositions</strong></li>
</ol>
<ul class="points">
<li><strong>Atomic Proposition:</strong> Atomic propositions are the simple propositions. It consists of a single proposition symbol. These are the sentences which must be either true or false. </li>
</ul>
<p><strong>Example:</strong></p>
<div class="codeblock"><textarea class="java" name="code">
a) 2+2 is 4, it is an atomic proposition as it is a true fact.
b) "The Sun is cold" is also a proposition as it is a false fact. 
</textarea></div>
<ul class="points">
<li><strong>Compound proposition:</strong> Compound propositions are constructed by combining simpler or atomic propositions, using parenthesis and logical connectives.</li>
</ul>
<p><strong>Example:</strong></p>
<div class="codeblock"><textarea class="java" name="code">
a) "It is raining today, and street is wet."
b) "Ankit is a doctor, and his clinic is in Mumbai." 
</textarea></div>
<h2 class="h2">Logical Connectives:</h2>
<p>Logical connectives are used to connect two simpler propositions or representing a sentence logically. We can create compound propositions with the help of logical connectives. There are mainly five connectives, which are given as follows:</p>
<ol class="points">
<li><strong>Negation:</strong> A sentence such as ¬ P is called negation of P. A literal can be either Positive literal or negative literal.</li>
<li><strong>Conjunction:</strong> A sentence which has <strong>∧ </strong>connective such as, <strong>P ∧ Q</strong> is called a conjunction.<br/>
<strong>Example:</strong> Rohan is intelligent and hardworking. It can be written as,<br/>
<strong>P= Rohan is intelligent</strong>,<br/>
<strong>Q= Rohan is hardworking.  → P∧ Q</strong>.</li>
<li><strong>Disjunction:</strong> A sentence which has ∨ connective, such as <strong>P ∨ Q</strong>. is called disjunction, where P and Q are the propositions.<br/>
<strong>Example: "Ritika is a doctor or Engineer"</strong>,<br/>
Here P= Ritika is Doctor. Q= Ritika is Doctor, so we can write it as <strong>P ∨ Q</strong>.</li>
<li><strong>Implication:</strong> A sentence such as P → Q, is called an implication. Implications are also known as if-then rules. It can be represented as<br/>
            <strong>If</strong> it is raining, then the street is wet.<br/>
        Let P= It is raining, and Q= Street is wet, so it is represented as P → Q</li>
<li><strong>Biconditional:</strong> A sentence such as <strong>P⇔ Q is a Biconditional sentence, example If I am breathing, then I am alive</strong><br/>
            P= I am breathing, Q= I am alive, it can be represented as P ⇔ Q.</li>
</ol>
<h3 class="h3">Following is the summarized table for Propositional Logic Connectives:</h3>
<img alt="Propositional logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/propositional-logic-in-ai.png"/>
<h2 class="h2">Truth Table: </h2>
<p>In propositional logic, we need to know the truth values of propositions in all possible scenarios. We can combine all the possible combination with logical connectives, and the representation of these combinations in a tabular format is called <strong>Truth table</strong>. Following are the truth table for all logical connectives: </p>
<img alt="Propositional logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/propositional-logic-in-ai2.png"/>
<img alt="Propositional logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/propositional-logic-in-ai3.png"/>
<h3 class="h3">Truth table with three propositions: </h3>
<p>We can build a proposition composing three propositions P, Q, and R. This truth table is made-up of 8n Tuples as we have taken three proposition symbols.</p>
<img alt="Propositional logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/propositional-logic-in-ai4.png"/>
<h3 class="h3">Precedence of connectives: </h3>
<p>Just like arithmetic operators, there is a precedence order for propositional connectors or logical operators.  This order should be followed while evaluating a propositional problem. Following is the list of the precedence order for operators:</p>
<table class="alt">
<tr>
<th>Precedence</th>
<th>Operators</th>
</tr>
<tr>
<td>First Precedence</td>
<td>Parenthesis</td>
</tr>
<tr>
<td>Second Precedence</td>
<td>Negation</td>
</tr>
<tr>
<td>Third Precedence</td>
<td>Conjunction(AND)</td>
</tr>
<tr>
<td>Fourth Precedence</td>
<td>Disjunction(OR)</td>
</tr>
<tr>
<td>Fifth Precedence</td>
<td>Implication</td>
</tr>
<tr>
<td>Six Precedence</td>
<td>Biconditional</td>
</tr>
</table>
<h4 class="n">Note: For better understanding use parenthesis to make sure of the correct interpretations. Such as ¬R∨ Q, It can be interpreted as (¬R) ∨ Q. </h4>
<h3 class="h3">Logical equivalence:</h3>
<p>Logical equivalence is one of the features of propositional logic. Two propositions are said to be logically equivalent if and only if the columns in the truth table are identical to each other.</p>
<p>Let's take two propositions A and B, so for logical equivalence, we can write it as A⇔B. In below truth table we can see that column for ¬A∨ B and A→B, are identical hence A is Equivalent to B </p>
<img alt="Propositional logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/propositional-logic-in-ai5.png"/>
<h3 class="h3">Properties of Operators:</h3>
<ul class="points">
<li><strong>Commutativity:</strong>
<ul class="points">
<li>P∧ Q= Q ∧ P, or</li>
<li>P ∨ Q = Q ∨ P.</li>
</ul>
</li>
<li><strong>Associativity:</strong>
<ul class="points">
<li>(P ∧ Q) ∧ R= P ∧ (Q ∧  R),</li>
<li>(P ∨ Q) ∨  R= P ∨ (Q ∨ R)</li>
</ul>
</li>
<li><strong>Identity element:</strong>
<ul class="points">
<li>P ∧ True = P,</li>
<li> P ∨ True= True.</li>
</ul>
</li>
<li><strong>Distributive:</strong>
<ul class="points">
<li>P∧ (Q ∨ R) = (P ∧ Q) ∨ (P ∧ R). </li>
<li>P ∨ (Q ∧ R) = (P ∨ Q) ∧ (P ∨ R).</li>
</ul>
</li>
<li><strong>DE Morgan's Law:</strong>
<ul class="points">
<li>¬ (P ∧ Q) = (¬P) ∨ (¬Q)</li>
<li>¬ (P ∨ Q) = (¬ P) ∧ (¬Q).</li>
</ul>
</li>
<li><strong>Double-negation elimination:</strong>
<ul class="points">
<li>¬ (¬P) = P.</li>
</ul>
</li>
</ul>
<h3 class="h3">Limitations of Propositional logic:</h3>
<ul class="points">
<li>We cannot represent relations like ALL, some, or none with propositional logic. Example:
<ol class="pointsa">
<li><strong>All the girls are intelligent.</strong></li>
<li><strong>Some apples are sweet.</strong></li>
</ol></li>
<li>Propositional logic has limited expressive power.</li>
<li>In propositional logic, we cannot describe statements in terms of their properties or logical relationships.</li>
</ul>
<h1 class="h1">Rules of Inference in Artificial intelligence</h1>
<h2 class="h2">Inference: </h2>
<p>In artificial intelligence, we need intelligent computers which can create new logic from old logic or by evidence, <strong>so generating the conclusions from evidence and facts is termed as Inference</strong>. </p>
<h2 class="h2">Inference rules:</h2>
<p>Inference rules are the templates for generating valid arguments. Inference rules are applied to derive proofs in artificial intelligence, and the proof is a sequence of the conclusion that leads to the desired goal. </p>
<p>In inference rules, the implication among all the connectives plays an important role. Following are some terminologies related to inference rules:</p>
<ul class="points">
<li><strong>Implication:</strong> It is one of the logical connectives which can be represented as P → Q. It is a Boolean expression.</li>
<li><strong>Converse:</strong> The converse of implication, which means the right-hand side proposition goes to the left-hand side and vice-versa. It can be written as Q → P.</li>
<li><strong>Contrapositive:</strong> The negation of converse is termed as contrapositive, and it can be represented as ¬ Q → ¬ P.</li>
<li><strong>Inverse:</strong> The negation of implication is called inverse. It can be represented as ¬ P → ¬ Q.</li>
</ul>
<p>From the above term some of the compound statements are equivalent to each other, which we can prove using truth table:</p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai.png"/>
<p>Hence from the above truth table, we can prove that P → Q is equivalent to ¬ Q → ¬ P, and Q→ P is equivalent to ¬ P → ¬ Q.</p>
<h2 class="h2">Types of Inference rules:</h2>
<h3 class="h3">1. Modus Ponens:</h3>
<p>The Modus Ponens rule is one of the most important rules of inference, and it states that if P and P → Q is true, then we can infer that Q will be true. It can be represented as: </p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai2.png"/>
<p><strong>Example: </strong></p>
<p>Statement-1:  "If I am sleepy then I go to bed" ==&gt; P→ Q<br/>
Statement-2:  "I am sleepy" ==&gt; P<br/>
Conclusion:  "I go to bed." ==&gt; Q. <br/>
Hence, we can say that, if P→ Q is true and P is true then Q will be true.</p>
<p><strong>Proof by Truth table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai3.png"/>
<h3 class="h3">2. Modus Tollens:</h3>
<p>The Modus Tollens rule state that if  P→ Q is true and <strong>¬ Q is true, then ¬ P</strong> will also true. It can be represented as: </p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai4.png"/>
<p><strong>Statement-1:</strong> "If I am sleepy then I go to bed" ==&gt; P→ Q <br/>
<strong>Statement-2:</strong> "I do not go to the bed."==&gt; ~Q<br/>
<strong>Statement-3:</strong> Which infers that "<strong>I am not sleepy</strong>" =&gt;  ~P</p>
<p><strong>Proof by Truth table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai5.png"/>
<h3 class="h3">3. Hypothetical Syllogism: </h3>
<p>The Hypothetical Syllogism rule state that if P→R is true whenever P→Q is true, and Q→R is true. It can be represented as the following notation:</p>
<p><strong>Example:</strong></p>
<p><strong>Statement-1:</strong> If you have my home key then you can unlock my home. <strong>P→Q</strong><br/>
<strong>Statement-2:</strong> If you can unlock my home then you can take my money.  <strong>Q→R</strong><br/>
<strong>Conclusion:</strong> If you have my home key then you can take my money. <strong>P→R</strong></p>
<p><strong><u>Proof by truth table:</u></strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai6.png"/>
<h3 class="h3">4. Disjunctive Syllogism: </h3>
<p>The Disjunctive syllogism rule state that if P∨Q is true, and ¬P is true, then Q will be true. It can be represented as: </p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai7.png"/>
<p><strong>Example:</strong></p>
<p><strong>Statement-1:</strong> Today is Sunday or Monday.  ==&gt;P∨Q<br/>
<strong>Statement-2:</strong> Today is not Sunday.  ==&gt; ¬P<br/>
<strong>Conclusion:</strong> Today is Monday. ==&gt; Q</p>
<p><strong>Proof by truth-table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai8.png"/>
<h3 class="h3">5. Addition:</h3>
<p>The Addition rule is one the common inference rule, and it states that If P is true, then P∨Q will be true.</p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai9.png"/>
<p><strong>Example:</strong>
<p><strong>Statement:</strong> I have a vanilla ice-cream. ==&gt; P<br/>
<strong>Statement-2:</strong> I have Chocolate ice-cream. <br/>
<strong>Conclusion:</strong> I have vanilla or chocolate ice-cream.  ==&gt; (P∨Q)</p>
<p><strong>Proof by Truth-Table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai10.png"/>
<h3 class="h3">6. Simplification:</h3>
<p>The simplification rule state that if <strong>P∧ Q</strong> is true, then <strong>Q or P</strong> will also be true. It can be represented as:</p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai11.png"/>
<p><strong>Proof by Truth-Table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai12.png"/>
<h3 class="h3">7. Resolution: </h3>
<p>The Resolution rule state that if P∨Q and  ¬ P∧R is true, then Q∨R will also be true. <strong>It can be represented as</strong> </p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai13.png"/>
<p><strong>Proof by Truth-Table:</strong></p>
<img alt="Rules of Inference in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/rules-of-inference-in-ai14.png"/>
<h1 class="h1">The Wumpus World in Artificial intelligence</h1>
<h2 class="h2">Wumpus world:</h2>
<p>The Wumpus world is a simple world example to illustrate the worth of a knowledge-based agent and to represent knowledge representation. It was inspired by a video game <strong>Hunt the Wumpus</strong> by Gregory Yob in 1973. </p>
<p>The Wumpus world is a cave which has 4/4 rooms connected with passageways. So there are total 16 rooms which are connected with each other. We have a knowledge-based agent who will go forward in this world. The cave has a room with a beast which is called Wumpus, who eats anyone who enters the room. The Wumpus can be shot by the agent, but the agent has a single arrow. In the Wumpus world, there are some Pits rooms which are bottomless, and if agent falls in Pits, then he will be stuck there forever. The exciting thing with this cave is that in one room there is a possibility of finding a heap of gold. So the agent goal is to find the gold and climb out the cave without fallen into Pits or eaten by Wumpus. The agent will get a reward if he comes out with gold, and he will get a penalty if eaten by Wumpus or falls in the pit.</p>
<h4 class="n">Note: Here Wumpus is static and cannot move. </h4>
<p>Following is a sample diagram for representing the Wumpus world. It is showing some rooms with Pits, one room with Wumpus and one agent at (1, 1) square location of the world. </p>
<img alt="The Wumpus World in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/the-wumpus-world-in-artificial-intelligence.png"/>
<p><strong>There are also some components which can help the agent to navigate the cave. These components are given as follows:</strong></p>
<ol class="pointsa">
<li>The rooms adjacent to the Wumpus room are smelly, so that it would have some stench. </li>
<li>The room adjacent to PITs has a breeze, so if the agent reaches near to PIT, then he will perceive the breeze.</li>
<li>There will be glitter in the room if and only if the room has gold.</li>
<li>The Wumpus can be killed by the agent if the agent is facing to it, and Wumpus will emit a horrible scream which can be heard anywhere in the cave. </li>
</ol>
<h2 class="h2">PEAS description of Wumpus world: </h2>
<p>To explain the Wumpus world we have given PEAS description as below:</p>
<h3 class="h3">Performance measure:</h3>
<ul class="points">
<li>+1000 reward points if the agent comes out of the cave with the gold.</li>
<li>-1000 points penalty for being eaten by the Wumpus or falling into the pit.</li>
<li>-1 for each action, and -10 for using an arrow.</li>
<li>The game ends if either agent dies or came out of the cave.</li>
</ul>
<h3 class="h3">Environment:</h3>
<ul class="points">
<li>A 4*4 grid of rooms.</li>
<li>The agent initially in room square [1, 1], facing toward the right.</li>
<li>Location of Wumpus and gold are chosen randomly except the first square [1,1].</li>
<li>Each square of the cave can be a pit with probability 0.2 except the first square.</li>
</ul>
<h3 class="h3">Actuators:</h3>
<ul class="points">
<li>Left turn, </li>
<li>Right turn</li>
<li>Move forward</li>
<li>Grab</li>
<li>Release</li>
<li>Shoot.</li>
</ul>
<h3 class="h3">Sensors:</h3>
<ul class="points">
<li>The agent will perceive the <strong>stench</strong> if he is in the room adjacent to the Wumpus. (Not diagonally).</li>
<li>The agent will perceive <strong>breeze</strong> if he is in the room directly adjacent to the Pit.</li>
<li>The agent will perceive the <strong>glitter</strong> in the room where the gold is present.</li>
<li>The agent will perceive the <strong>bump</strong> if he walks into a wall.</li>
<li>When the Wumpus is shot, it emits a horrible <strong>scream</strong> which can be perceived anywhere in the cave.</li>
<li>These percepts can be represented as five element list, in which we will have different indicators for each sensor. </li>
<li>Example if agent perceives stench, breeze, but no glitter, no bump, and no scream then it can be represented as:<br/>
<strong>[Stench, Breeze, None, None, None]</strong>.</li>
</ul>
<h2 class="h2">The Wumpus world Properties:</h2>
<ul class="points">
<li><strong>Partially observable:</strong> The Wumpus world is partially observable because the agent can only perceive the close environment such as an adjacent room.</li>
<li><strong>Deterministic:</strong> It is deterministic, as the result and outcome of the world are already known.</li>
<li><strong>Sequential:</strong> The order is important, so it is sequential.</li>
<li><strong>Static:</strong> It is static as Wumpus and Pits are not moving.</li>
<li><strong>Discrete:</strong> The environment is discrete.</li>
<li><strong>One agent:</strong> The environment is a single agent as we have one agent only and Wumpus is not considered as an agent. </li>
</ul>
<h2 class="h2">Exploring the Wumpus world:</h2>
<p>Now we will explore the Wumpus world and will determine how the agent will find its goal by applying logical reasoning. </p>
<p><strong>Agent's First step:</strong></p>
<p>Initially, the agent is in the first room or on the square [1,1], and we already know that this room is safe for the agent, so to represent on the below diagram (a) that room is safe we will add symbol OK. Symbol A is used to represent agent, symbol B for the breeze, G for Glitter or gold, V for the visited room, P for pits, W for Wumpus. </p>
<p>At Room [1,1] agent does not feel any breeze or any Stench which means the adjacent squares are also OK.</p>
<img alt="The Wumpus World in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/the-wumpus-world-in-artificial-intelligence2.png"/>
<p><strong>Agent's second Step:</strong></p>
<p>Now agent needs to move forward, so it will either move to [1, 2], or [2,1]. Let's suppose agent moves to the room [2, 1], at this room agent perceives some breeze which means Pit is around this room. The pit can be in [3, 1], or [2,2], so we will add symbol P? to say that, is this Pit room?</p>
<p>Now agent will stop and think and will not make any harmful move. The agent will go back to the [1, 1] room.  The room [1,1], and [2,1] are visited by the agent, so we will use symbol V to represent the visited squares.</p>
<p><strong>Agent's third step:</strong></p>
<p>At the third step, now agent will move to the room [1,2] which is OK.  In the room [1,2] agent perceives a stench which means there must be a Wumpus nearby. But Wumpus cannot be in the room [1,1] as by rules of the game, and also not in [2,2] (Agent had not detected any stench when he was at [2,1]). Therefore agent infers that Wumpus is in the room [1,3], and in current state, there is no breeze which means in [2,2] there is no Pit and no Wumpus. So it is safe, and we will mark it OK, and the agent moves further in [2,2].</p>
<img alt="The Wumpus World in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/the-wumpus-world-in-artificial-intelligence3.png"/>
<p><strong>Agent's fourth step:</strong></p>
<p>At room [2,2], here no stench and no breezes present so let's suppose agent decides to move to [2,3]. At room [2,3] agent perceives glitter, so it should grab the gold and climb out of the cave. </p>
<h1 class="h1">Knowledge-base for Wumpus world</h1>
<p>As in the previous topic we have learned about the wumpus world and how a knowledge-based agent evolves the world. Now in this topic, we will create a knowledge base for the wumpus world, and will derive some proves for the Wumpus-world using propositional logic.</p>
<p>The agent starts visiting from first square [1, 1], and we already know that this room is safe for the agent. To build a knowledge base for wumpus world, we will use some rules and atomic propositions. We need symbol [i, j] for each location in the wumpus world, where i is for the location of rows, and j for column location.</p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world.png"/>
<h3 class="h3">Atomic proposition variable for Wumpus world:</h3>
<ul class="points">
<li>Let <strong>P<sub>i,j</sub></strong> be true if there is a Pit in the room [i, j].</li>
<li>Let <strong>B<sub>i,j</sub></strong> be true if agent perceives	breeze in [i, j], (dead or alive). </li>
<li>Let <strong>W<sub>i,j</sub></strong> be true if there is wumpus in the square[i, j].</li>
<li>Let <strong>S<sub>i,j</sub></strong> be true if agent perceives stench in the square [i, j].</li>
<li>Let <strong>V<sub>i,j</sub></strong> be true if that square[i, j] is visited.</li>
<li>Let <strong>G<sub>i,j</sub></strong> be true if there is gold (and glitter) in the square [i, j]. </li>
<li>Let <strong>OK<sub>i,j</sub></strong> be true if the room is safe.</li>
</ul>
<h4 class="n">Note: For a 4 * 4 square board, there will be 7*4*4= 122 propositional variables. </h4>
<h3 class="h3">Some Propositional Rules for the wumpus world:</h3>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world2.png"/>
<h4 class="n">Note: lack of variables gives us similar rules for each cell. </h4>
<h3 class="h3">Representation of Knowledgebase for Wumpus world:</h3>
<p>Following is the Simple KB for wumpus world when an agent moves from room [1, 1], to room [2,1]:</p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world3.png"/>
<p>Here in the first row, we have mentioned propositional variables for room[1,1], which is showing that room does not have wumpus(¬ W<sub>11</sub>), no stench (<strong>¬S<sub>11</sub></strong>),  no Pit(<strong>¬P<sub>11</sub></strong>), no breeze(<strong>¬B<sub>11</sub></strong>), no gold (<strong>¬G<sub>11</sub></strong>), visited (<strong>V<sub>11</sub></strong>), and the room is Safe(<strong>OK<sub>11</sub></strong>).</p>
<p>In the second row, we have mentioned propositional variables for room [1,2], which is showing that there is no wumpus, stench and breeze are unknown as an agent has not visited room [1,2], no Pit, not visited yet, and the room is safe.</p>
<p>In the third row we have mentioned propositional variable for room[2,1], which is showing that there is no wumpus(¬ W21), no stench (<strong>¬S<sub>21</sub></strong>), no Pit (<strong>¬P<sub>21</sub></strong>), Perceives breeze(<strong>B<sub>21</sub></strong>), no glitter(<strong>¬G<sub>21</sub></strong>),  visited (<strong>V<sub>21</sub></strong>),  and room is safe (<strong>OK<sub>21</sub></strong>).</p>
<h2 class="h2">Prove that Wumpus is in the room (1, 3)</h2>
<p>We can prove that wumpus is in the room (1, 3) using propositional rules which we have derived for the wumpus world and using inference rule. </p>
<ul class="points">
<li><strong>Apply Modus Ponens with ¬S11 and R1: </strong></li>
</ul>
<p>We will firstly apply MP rule with R1 which is ¬S<sub>11</sub>  → ¬ W<sub>11</sub> ^ ¬ W<sub>12</sub>  ^ ¬ W<sub>21</sub>, and <strong>¬S<sub>11</sub></strong> which will give the output  ¬ W<sub>11</sub> ^   W<sub>12</sub>  ^ W<sub>12</sub>.</p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world4.png"/>
<ul class="points">
<li><strong>Apply And-Elimination Rule: </strong></li>
</ul>
<p>After applying And-elimination rule to ¬ W<sub>11</sub> ∧  ¬ W<sub>12</sub>  ∧  ¬ W<sub>21</sub>, we will get three statements:<br/>
<strong>¬ W<sub>11</sub>, ¬ W<sub>12</sub>,  and  ¬W<sub>21</sub></strong>. </p>
<ul class="points">
<li><strong>Apply Modus Ponens to ¬S<sub>21</sub>, and R2:</strong></li>
</ul>
<p>Now we will apply Modus Ponens to ¬S<sub>21</sub> and R2 which is ¬S<sub>21</sub>  →  ¬ W<sub>21</sub> ∧¬ W<sub>22</sub> ∧ ¬ W<sub>31</sub>, which will give the Output as  <strong>¬ W<sub>21</sub> ∧ ¬ W<sub>22</sub> ∧¬ W<sub>31</sub></strong></p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world5.png"/>
<ul class="points">
<li><strong>Apply And -Elimination rule: </strong></li>
</ul>
<p>Now again apply And-elimination rule to <strong>¬ W<sub>21</sub> ∧ ¬ W<sub>22</sub> ∧¬ W<sub>31</sub></strong>, We will get three statements:<br/>
<strong>¬ W<sub>21</sub>,  ¬ W<sub>22</sub>, and ¬ W<sub>31</sub></strong>. </p>
<ul class="points">
<li><strong>Apply MP to S<sub>12</sub> and R4: </strong></li>
</ul>
<p>Apply Modus Ponens to <strong>S<sub>12</sub></strong> and <strong>R<sub>4</sub></strong> which is <strong>S<sub>12</sub>  →   W<sub>13</sub> ∨. W<sub>12</sub> ∨. W<sub>22</sub> ∨.W<sub>11</sub></strong>,  we will get the output as <strong>W<sub>13</sub>∨ W<sub>12</sub> ∨ W<sub>22</sub> ∨.W<sub>11</sub></strong>. </p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world6.png"/>
<ul class="points">
<li><strong>Apply Unit resolution on W<sub>13</sub> ∨ W<sub>12</sub> ∨ W<sub>22</sub> ∨W<sub>11</sub>  and ¬ W<sub>11</sub> :</strong></li>
</ul>
<p>After applying Unit resolution formula on   W<sub>13</sub> ∨ W<sub>12</sub> ∨ W<sub>22</sub> ∨W<sub>11</sub>  and ¬ W<sub>11</sub> we will get W<sub>13</sub> ∨ W<sub>12</sub> ∨ W<sub>22</sub>. </p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world7.png"/>
<ul class="points">
<li><strong>Apply Unit resolution on W<sub>13</sub> ∨ W<sub>12</sub> ∨ W<sub>22</sub>   and ¬ W<sub>22</sub> :</strong></li>
</ul>
<p>After applying Unit resolution on <strong>W<sub>13</sub> ∨ W<sub>12</sub> ∨ W<sub>22</sub></strong>,  and  <strong>¬W<sub>22</sub></strong>, we will get <strong>W<sub>13</sub> ∨ W<sub>12</sub></strong> as output. </p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world8.png"/>
<ul class="points">
<li><strong>Apply Unit Resolution on  W<sub>13</sub> ∨ W<sub>12</sub>  and ¬ W<sub>12</sub> :</strong></li>
</ul>
<p>After Applying Unit resolution on <strong>W<sub>13</sub> ∨ W<sub>12</sub>  and  ¬ W<sub>12</sub></strong>, we will get <strong>W<sub>13</sub></strong> as an output, hence it is proved that the Wumpus is in the room [1, 3]. </p>
<img alt="Knowledge-base for Wumpus world" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-base-for-wumpus-world9.png"/>
<h1 class="h1">First-Order Logic in Artificial intelligence</h1>
<p>In the topic of Propositional logic, we have seen that how to represent statements using propositional logic. But unfortunately, in propositional logic, we can only represent the facts, which are either true or false. PL is not sufficient to represent the complex sentences or natural language statements. The propositional logic has very limited expressive power. Consider the following sentence, which we cannot represent using PL logic.</p>
<ul class="points">
<li><strong>"Some humans are intelligent", or</strong></li>
<li><strong>"Sachin likes cricket."</strong></li>
</ul>
<p>To represent the above statements, PL logic is not sufficient, so we required some more powerful logic, such as first-order logic. </p>
<h2 class="h2">First-Order logic: </h2>
<ul class="points">
<li>First-order logic is another way of knowledge representation in artificial intelligence. It is an extension to propositional logic.</li>
<li>FOL is sufficiently expressive to represent the natural language statements in a concise way.</li>
<li>First-order logic is also known as <strong>Predicate logic or First-order predicate logic</strong>. First-order logic is a powerful language that develops information about the objects in a more easy way and can also express the relationship between those objects.</li>
<li>First-order logic (like natural language) does not only assume that the world contains facts like propositional logic but also assumes the following things in the world:
<ul class="points">
<li><strong>Objects:</strong> A, B, people, numbers, colors, wars, theories, squares, pits, wumpus, ......</li>
<li><strong>Relations:</strong> <strong>It can be unary relation such as:</strong> red, round, is adjacent, <strong>or n-any relation such as:</strong> the sister of, brother of, has color, comes between</li>
<li><strong>Function:</strong> Father of, best friend, third inning of, end of, ......</li>
</ul></li>
<li>As a natural language, first-order logic also has two main parts:
<ol class="pointsa">
<li><strong>Syntax</strong></li>
<li><strong>Semantics</strong></li>
</ol></li>
</ul>
<h2 class="h2">Syntax of First-Order logic:</h2>
<p>The syntax of FOL determines which collection of symbols is a logical expression in first-order logic. The basic syntactic elements of first-order logic are symbols. We write statements in short-hand notation in FOL. </p>
<h3 class="h3">Basic Elements of First-order logic: </h3>
<p>Following are the basic elements of FOL syntax:</p>
<table class="alt">
<tr>
<td><strong>Constant</strong></td>
<td>1, 2, A, John, Mumbai, cat,....</td>
</tr>
<tr>
<td><strong>Variables</strong></td>
<td>x, y, z, a, b,....</td>
</tr>
<tr>
<td><strong>Predicates</strong></td>
<td>Brother, Father, &gt;,....</td>
</tr>
<tr>
<td><strong>Function</strong></td>
<td>sqrt, LeftLegOf, .... </td>
</tr>
<tr>
<td><strong>Connectives</strong></td>
<td>∧, ∨, ¬, ⇒, ⇔</td>
</tr>
<tr>
<td><strong>Equality</strong></td>
<td>==</td>
</tr>
<tr>
<td><strong>Quantifier</strong></td>
<td>∀, ∃</td>
</tr>
</table>
<h3 class="h3">Atomic sentences:</h3>
<ul class="points">
<li>Atomic sentences are the most basic sentences of first-order logic. These sentences are formed from a predicate symbol followed by a parenthesis with a sequence of terms.</li>
<li>We can represent atomic sentences as <strong>Predicate (term1, term2, ......, term n)</strong>.</li>
</ul>
<p><strong>Example: Ravi and Ajay are brothers: =&gt;  Brothers(Ravi, Ajay).<br/>
                Chinky is a cat: =&gt;  cat (Chinky)</strong>.</p>
<h3 class="h3">Complex Sentences:</h3>
<ul class="points">
<li>Complex sentences are made by combining atomic sentences using connectives.</li>
</ul>
<p><strong>First-order logic statements can be divided into two parts:</strong></p>
<ul class="points">
<li><strong>Subject:</strong> Subject is the main part of the statement. </li>
<li><strong>Predicate:</strong> A predicate can be defined as a relation, which binds two atoms together in a statement. </li>
</ul>
<p><strong>Consider the statement: "x is an integer."</strong>, it consists of two parts, the first part x is the subject of the statement and second part "is an integer," is known as a predicate. </p>
<img alt="First-Order Logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/first-order-logic-in-artificial-intelligence.png"/>
<h2 class="h2">Quantifiers in First-order logic:</h2>
<ul class="points">
<li>A quantifier is a language element which generates quantification, and quantification specifies the quantity of specimen in the universe of discourse.</li>
<li>These are the symbols that permit to determine or identify the range and scope of the variable in the logical expression. There are two types of quantifier:
<ol class="pointsa">
<li><strong>Universal Quantifier, (for all, everyone, everything)</strong></li>
<li><strong>Existential quantifier, (for some, at least one).</strong></li>
</ol></li>
</ul>
<h3 class="h3">Universal Quantifier: </h3>
<p>Universal quantifier is a symbol of logical representation, which specifies that the statement within its range is true for everything or every instance of a particular thing. </p>
<p>The Universal quantifier is represented by a symbol ∀, which resembles an inverted A. </p>
<h4 class="n">Note: In universal quantifier we use implication "→". </h4>
<p>If x is a variable, then ∀x is read as:</p>
<ul class="points">
<li><strong>For all x</strong></li>
<li><strong>For each x </strong></li>
<li><strong>For every x.</strong></li>
</ul>
<h3 class="h3">Example:</h3>
<p><strong>All man drink coffee.</strong></p>
<p>Let a variable x which refers to a cat so all x can be represented in UOD as below:	</p>
<img alt="First-Order Logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/first-order-logic-in-artificial-intelligence2.png"/>
<p><strong>∀x  man(x) → drink (x, coffee). </strong></p>
<p>It will be read as: There are all x where x is a man who drink coffee.</p>
<h2 class="h2">Existential Quantifier:</h2>
<p>Existential quantifiers are the type of quantifiers, which express that the statement within its scope is true for at least one instance of something.</p>
<p>It is denoted by the logical operator ∃, which resembles as inverted E. When it is used with a predicate variable then it is called as an existential quantifier.</p>
<h4 class="n">Note: In Existential quantifier we always use AND or Conjunction symbol (∧). </h4>
<p>If x is a variable, then existential quantifier will be ∃x or ∃(x). And it will be read as:</p>
<ul class="points">
<li><strong>There exists a 'x.'</strong></li>
<li><strong>For some 'x.'</strong></li>
<li><strong>For at least one 'x.'</strong></li>
</ul>
<h3 class="h3">Example: </h3>
<p><strong>Some boys are intelligent.</strong></p>
<img alt="First-Order Logic in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/first-order-logic-in-artificial-intelligence3.png"/>
<p><strong>∃x: boys(x) ∧ intelligent(x) </strong></p>
<p>It will be read as: There are some x where x is a boy who is intelligent. </p>
<h2 class="h2">Points to remember:</h2>
<ul class="points">
<li>The main connective for universal quantifier <strong>∀</strong> is implication <strong>→</strong>.</li>
<li>The main connective for existential quantifier <strong>∃</strong> is and <strong>∧</strong>.</li>
</ul>
<h2 class="h2">Properties of Quantifiers:</h2>
<ul class="points">
<li>In universal quantifier, ∀x∀y is similar to ∀y∀x.</li>
<li>In Existential quantifier, ∃x∃y is similar to ∃y∃x.</li>
<li>∃x∀y is not similar to ∀y∃x.</li>
</ul>
<p class="pq">Some Examples of FOL using quantifier:</p>
<p><strong>1. All birds fly.</strong><br/>
In this question the predicate is "<strong>fly(bird)</strong>." <br/>
And since there are all birds who fly so it will be represented as follows.<br/>
              <strong>∀x  bird(x)  →fly(x)</strong>.</p>
<p><strong>2. Every man respects his parent.</strong><br/>
In this question, the predicate is "<strong>respect(x, y)," where x=man, and y= parent</strong>.<br/>
Since there is every man so will use ∀, and it will be represented as follows:<br/>
              <strong>∀x  man(x)  →  respects (x, parent)</strong>.</p>
<p><strong>3. Some boys play cricket.</strong><br/>
In this question, the predicate is "<strong>play(x, y)</strong>," where x= boys, and y= game. Since there are some boys so we will use <strong>∃, and it will be represented as</strong>:<br/>
              <strong>∃x  boys(x) →  play(x, cricket)</strong>. </p>
<p><strong>4. Not all students like both Mathematics and Science.</strong><br/>
In this question, the predicate is "<strong>like(x, y)," where x= student, and y= subject</strong>.<br/>
Since there are not all students, so we will use <strong>∀ with negation,  so</strong> following representation for this:<br/>
              <strong>¬∀ (x) [ student(x) →  like(x, Mathematics) ∧ like(x, Science)].</strong></p>
<p><strong>5. Only one student failed in Mathematics.</strong><br/>
In this question, the predicate is "<strong>failed(x, y)," where x= student, and y= subject</strong>.<br/>
Since there is only one student who failed in Mathematics, so we will use following representation for this:<br/>
              <strong>∃(x) [ student(x) → failed (x, Mathematics) ∧∀ (y) [¬(x==y) ∧ student(y) → ¬failed (x, Mathematics)]</strong>.</p>
<h2 class="h2">Free and Bound Variables:</h2>
<p>The quantifiers interact with variables which appear in a suitable way. There are two types of variables in First-order logic which are given below:</p>
<p><strong>Free Variable:</strong> A variable is said to be a free variable in a formula if it occurs outside the scope of the quantifier.</p>
<p>          <strong>Example: ∀x ∃(y)[P (x, y, z)], where z is a free variable.</strong></p>
<p><strong>Bound Variable:</strong> A variable is said to be a bound variable in a formula if it occurs within the scope of the quantifier.</p>
<p>          <strong>Example: ∀x [A (x) B( y)], here x and y are the bound variables.</strong> </p>
<h1 class="h1">Knowledge Engineering in First-order logic</h1>
<h2 class="h2">What is knowledge-engineering?</h2>
<p>The process of constructing a knowledge-base in first-order logic is called as knowledge- engineering. In <strong>knowledge-engineering</strong>, someone who investigates a particular domain, learns important concept of that domain, and generates a formal representation of the objects, is known as <strong>knowledge engineer</strong>.</p>
<p>In this topic, we will understand the Knowledge engineering process in an electronic circuit domain, which is already familiar. This approach is mainly suitable for creating <strong>special-purpose knowledge base</strong>.</p>
<h2 class="h2">The knowledge-engineering process:</h2>
<p>Following are some main steps of the knowledge-engineering process. Using these steps, we will develop a knowledge base which will allow us to reason about digital circuit (<strong>One-bit full adder</strong>) which is given below</p>
<img alt="Knowledge Engineering in First-order logic" src="https://static.javatpoint.com/tutorial/ai/images/ai-knowledge-engineering-in-first-order-logic.png"/>
<h3 class="h3">1. Identify the task: </h3>
<p>The first step of the process is to identify the task, and for the digital circuit, there are various reasoning tasks.</p>
<p>At the first level or highest level, we will examine the functionality of the circuit:</p>
<ul class="points">
<li><strong>Does the circuit add properly?</strong></li>
<li><strong>What will be the output of gate A2, if all the inputs are high?</strong></li>
</ul>
<p>At the second level, we will examine the circuit structure details such as:</p>
<ul class="points">
<li><strong>Which gate is connected to the first input terminal?</strong></li>
<li><strong>Does the circuit have feedback loops?</strong></li>
</ul>
<h3 class="h3">2. Assemble the relevant knowledge:</h3>
<p>In the second step, we will assemble the relevant knowledge which is required for digital circuits. So for digital circuits, we have the following required knowledge:</p>
<ul class="points">
<li>Logic circuits are made up of wires and gates.</li>
<li>Signal flows through wires to the input terminal of the gate, and each gate produces the corresponding output which flows further.</li>
<li>In this logic circuit, there are four types of gates used: <strong>AND, OR, XOR, and NOT</strong>.</li>
<li>All these gates have one output terminal and two input terminals (except NOT gate, it has one input terminal). </li>
</ul>
<h3 class="h3">3. Decide on vocabulary: </h3>
<p>The next step of the process is to select functions, predicate, and constants to represent the circuits, terminals, signals, and gates. Firstly we will distinguish the gates from each other and from other objects. Each gate is represented as an object which is named by a constant, such as, <strong>Gate(X1)</strong>. The functionality of each gate is determined by its type, which is taken as constants such as <strong>AND, OR, XOR, or NOT</strong>. Circuits will be identified by a predicate: <strong>Circuit (C1)</strong>.</p>
<p>For the terminal, we will use predicate: <strong>Terminal(x)</strong>.</p>
<p>For gate input, we will use the function <strong>In(1, X1)</strong> for denoting the first input terminal of the gate, and for output terminal we will use <strong>Out (1, X1)</strong>.</p>
<p>The function <strong>Arity(c, i, j)</strong> is used to denote that circuit c has i input, j output.</p>
<p>The connectivity between gates can be represented by predicate <strong>Connect(Out(1, X1), In(1, X1))</strong>.</p>
<p>We use a unary predicate <strong>On (t)</strong>, which is true if the signal at a terminal is on.</p>
<h3 class="h3">4. Encode general knowledge about the domain:</h3>
<p>To encode the general knowledge about the logic circuit, we need some following rules:</p>
<ul class="points">
<li>If two terminals are connected then they have the same input signal, it can be represented as: </li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  t1, t2 Terminal (t1) ∧ Terminal (t2) ∧ Connect (t1, t2) → Signal (t1) = Signal (2). 
</textarea></div>
<ul class="points">
<li>Signal at every terminal will have either value 0 or 1, it will be represented as:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  t Terminal (t) →Signal (t) = 1 ∨Signal (t) = 0.
</textarea></div>
<ul class="points">
<li>Connect predicates are commutative:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  t1, t2 Connect(t1, t2)  →  Connect (t2, t1). 	
</textarea></div>
<ul class="points">
<li>Representation of types of gates:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ r = Type(g) → r = OR ∨r = AND ∨r = XOR ∨r = NOT. 
</textarea></div>
<ul class="points">
<li>Output of AND gate will be zero if and only if any of its input is zero. </li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ Type(g) = AND →Signal (Out(1, g))= 0 ⇔  ∃n Signal (In(n, g))= 0. 
</textarea></div>
<ul class="points">
<li>Output of  OR  gate is 1 if and only if any of its input is 1:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ Type(g) = OR → Signal (Out(1, g))= 1 ⇔  ∃n Signal (In(n, g))= 1 
</textarea></div>
<ul class="points">
<li>Output of XOR gate is 1 if and only if its inputs are different:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ Type(g) = XOR → Signal (Out(1, g)) = 1 ⇔  Signal (In(1, g)) ≠ Signal (In(2, g)).
</textarea></div>
<ul class="points">
<li>Output of NOT gate is invert of its input:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ Type(g) = NOT →   Signal (In(1, g)) ≠ Signal (Out(1, g)).
</textarea></div>
<ul class="points">
<li>All the gates in the above circuit have two inputs and one output (except NOT gate). </li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) ∧ Type(g) = NOT →   Arity(g, 1, 1) 
∀  g Gate(g) ∧ r =Type(g)  ∧ (r= AND ∨r= OR ∨r= XOR) →  Arity (g, 2, 1). 
</textarea></div>
<ul class="points">
<li>All gates are logic circuits:</li>
</ul>
<div class="codeblock"><textarea class="java" name="code">
∀  g Gate(g) → Circuit (g). 
</textarea></div>
<h3 class="h3">5. Encode a description of the problem instance:</h3>
<p>Now we encode problem of circuit C1, firstly we categorize the circuit and its gate components. This step is easy if ontology about the problem is already thought. This step involves the writing simple atomics sentences of instances of concepts, which is known as ontology.</p>
<p>For the given circuit C1, we can encode the problem instance in atomic sentences as below:</p>
<p>Since in the circuit there are two XOR, two AND, and one OR gate so atomic sentences for these gates will be: </p>
<div class="codeblock"><textarea class="java" name="code">
For XOR gate: Type(x1)= XOR, Type(X2) = XOR
For AND gate: Type(A1) = AND, Type(A2)= AND
For OR gate: Type (O1) = OR.  
</textarea></div>
<p>And then represent the connections between all the gates.</p>
<h4 class="n">Note: Ontology defines a particular theory of the nature of existence. </h4>
<h3 class="h3">6. Pose queries to the inference procedure and get answers:</h3>
<p>In this step, we will find all the possible set of values of all the terminal for the adder circuit. The first query will be: </p>
<p>What should be the combination of input which would generate the first output of circuit C1, as 0 and a second output to be 1? </p>
<div class="codeblock"><textarea class="java" name="code">
∃ i1, i2, i3 Signal (In(1, C1))=i1  ∧  Signal (In(2, C1))=i2  ∧ Signal (In(3, C1))= i3
 ∧ Signal (Out(1, C1)) =0 ∧ Signal (Out(2, C1))=1
</textarea></div>
<h3 class="h3">7. Debug the knowledge base:</h3>
<p>Now we will debug the knowledge base, and this is the last step of the complete process. In this step, we will try to debug the issues of knowledge base. </p>
<p>In the knowledge base, we may have omitted assertions like 1 ≠ 0. </p>
<h1 class="h1">Inference in First-Order Logic</h1>
<p>Inference in First-Order Logic is used to deduce new facts or sentences from existing sentences. Before understanding the FOL inference rule, let's understand some basic terminologies used in FOL.</p>
<p><strong>Substitution: </strong></p>
<p>Substitution is a fundamental operation performed on terms and formulas. It occurs in all inference systems in first-order logic. The substitution is complex in the presence of quantifiers in FOL. If we write <strong>F[a/x]</strong>, so it refers to substitute a constant "<strong>a</strong>" in place of variable "<strong>x</strong>". </p>
<h4 class="n">Note: First-order logic is capable of expressing facts about some or all objects in the universe. </h4>
<p><strong>Equality: </strong></p>
<p>First-Order logic does not only use predicate and terms for making atomic sentences but also uses another way, which is equality in FOL. For this, we can use <strong>equality symbols</strong> which specify that the two terms refer to the same object. </p>
<p><strong>Example: Brother (John) = Smith.</strong></p>
<p>As in the above example, the object referred by the <strong>Brother (John)</strong> is similar to the object referred by <strong>Smith</strong>. The equality symbol can also be used with negation to represent that two terms are not the same objects. </p>
<p><strong>Example: ￢(x=y) which is equivalent to x ≠y.</strong></p>
<h2 class="h2">FOL inference rules for quantifier:</h2>
<p>As propositional logic we also have inference rules in first-order logic, so following are some basic inference rules in FOL:</p>
<ul class="points">
<li><strong>Universal Generalization</strong></li>
<li><strong>Universal Instantiation </strong></li>
<li><strong>Existential Instantiation</strong></li>
<li><strong>Existential introduction</strong></li>
</ul>
<p><strong>1. Universal Generalization:</strong></p>
<ul class="points">
<li>Universal generalization is a valid inference rule which states that if premise P(c) is true for any arbitrary element c in the universe of discourse, then we can have a conclusion as ∀ x P(x).</li>
<li>It can be represented as: <img alt="Inference in First-Order Logic" class="vmiddle" src="https://static.javatpoint.com/tutorial/ai/images/ai-inference-in-first-order-logic.png"/>.</li>
<li>This rule can be used if we want to show that every element has a similar property.</li>
<li>In this rule, x must not appear as a free variable.</li>
</ul>
<p><strong>Example:</strong> Let's represent, P(c): "<strong>A byte contains 8 bits</strong>", so for <strong>∀ x P(x)</strong> "<strong>All bytes contain 8 bits</strong>.", it will also be true.</p>
<p><strong>2. Universal Instantiation: </strong></p>
<ul class="points">
<li>Universal instantiation is also called as universal elimination or UI is a valid inference rule. It can be applied multiple times to add new sentences. </li>
<li>The new KB is logically equivalent to the previous KB.</li>
<li>As per UI, <strong>we can infer any sentence obtained by substituting a ground term for the variable</strong>.</li>
<li>The UI rule state that we can infer any sentence P(c) by substituting a ground term c (a constant within domain x) from  <strong>∀ x P(x) for any object in the universe of discourse</strong>.</li>
<li>It can be represented as:<img alt="Inference in First-Order Logic" class="vmiddle" src="https://static.javatpoint.com/tutorial/ai/images/ai-inference-in-first-order-logi2.png"/>.</li>
</ul>
<p><strong>Example:1.</strong></p>
<p>IF  "Every person like ice-cream"=&gt; ∀x P(x) so we can infer that <br/>
"John likes ice-cream" =&gt; P(c)</p>
<p><strong>Example: 2.</strong></p>
<p>Let's take a famous example,
<p>"All kings who are greedy are Evil." So let our knowledge base contains this detail as in the form of FOL:
<p><strong>∀x king(x) ∧ greedy (x) → Evil (x),</strong></p>
<p>So from this information, we can infer any of the following statements using Universal Instantiation: </p>
<ul class="points">
<li><strong>King(John) ∧ Greedy (John) → Evil (John),</strong></li>
<li><strong>King(Richard) ∧ Greedy (Richard) → Evil (Richard),</strong></li>
<li><strong>King(Father(John)) ∧ Greedy (Father(John)) → Evil (Father(John)),</strong></li>
</ul>
<p><strong>3. Existential Instantiation: </strong></p>
<ul class="points">
<li>Existential instantiation is also called as Existential Elimination, which is a valid inference rule in first-order logic.</li>
<li>It can be applied only once to replace the existential sentence.</li>
<li>The new KB is not logically equivalent to old KB, but it will be satisfiable if old KB was satisfiable.</li>
<li>This rule states that one can infer P(c) from the formula given in the form of  ∃x P(x) for a new constant symbol c.</li>
<li>The restriction with this rule is that c used in the rule must be a new term for which P(c ) is true.</li>
<li>It can be represented as:<img alt="Inference in First-Order Logic" class="vmiddle" src="https://static.javatpoint.com/tutorial/ai/images/ai-inference-in-first-order-logic3.png"/></li>
</ul>
<p><strong>Example:</strong></p>
<p>From the given sentence: <strong>∃x Crown(x) ∧ OnHead(x, John),</strong> </p>
<p>So we can infer: <strong>Crown(K) ∧ OnHead( K, John),</strong> as long as K does not appear in the knowledge base. </p>
<ul class="points">
<li>The above used K is a constant symbol, which is called <strong>Skolem constant</strong>.</li>
<li>The Existential instantiation is a special case of <strong>Skolemization process</strong>. </li>
</ul>
<p><strong>4. Existential introduction </strong></p>
<ul class="points">
<li>An existential introduction is also known as an existential generalization, which is a valid inference rule in first-order logic.</li>
<li>This rule states that if there is some element c in the universe of discourse which has a property P, then we can infer that there exists something in the universe which has the property P.</li>
<li>It can be represented as: <img alt="Inference in First-Order Logic" class="vmiddle" src="https://static.javatpoint.com/tutorial/ai/images/ai-inference-in-first-order-logic4.png"/></li>
<li><strong>Example: Let's say that, </strong> <br/>
"Priyanka got good marks in English."<br/>
"Therefore, someone got good marks in English."</li>
</ul>
<h2 class="h2">Generalized Modus Ponens Rule:</h2>
<p>For the inference process in FOL, we have a single inference rule which is called Generalized Modus Ponens. It is lifted version of Modus ponens. </p>
<p>Generalized Modus Ponens can be summarized as, " P implies Q and P is asserted to be true, therefore Q must be True." </p>
<p>According to Modus Ponens, for atomic sentences <strong>pi, pi', q</strong>. Where there is a substitution θ such that SUBST <strong>(θ, pi',)  = SUBST(θ, pi)</strong>, it can be represented as: </p>
<img alt="Inference in First-Order Logic" src="https://static.javatpoint.com/tutorial/ai/images/ai-inference-in-first-order-logic5.png"/>
<p><strong>Example:</strong></p>
<p><strong>We will use this rule for Kings are evil, so we will find some x such that x is king, and x is greedy so we can infer that x is evil. </strong></p>
<div class="codeblock"><textarea class="java" name="code">
Here let say, p1' is king(John)        p1 is king(x)
p2' is Greedy(y)                       p2 is Greedy(x)
θ is {x/John, y/John}                  q is evil(x)
SUBST(θ,q).                                                      
</textarea></div>
<h1 class="h1">What is Unification?</h1>
<ul class="points">
<li>Unification is a process of making two different logical atomic expressions identical by finding a substitution. Unification depends on the substitution process.</li>
<li>It takes two literals as input and makes them identical using substitution. </li>
<li>Let Ψ<sub>1</sub> and Ψ<sub>2</sub> be two atomic sentences and 𝜎 be a unifier such that, <strong>Ψ<sub>1</sub>𝜎 = Ψ<sub>2</sub>𝜎</strong>, then it can be expressed as <strong>UNIFY(Ψ<sub>1</sub>, Ψ<sub>2</sub>)</strong>.</li>
<li><strong>Example: Find the MGU for Unify{King(x), King(John)}</strong></li>
</ul>
<p>Let Ψ<sub>1</sub> = King(x), Ψ<sub>2</sub> = King(John), </p>
<p><strong>Substitution θ = {John/x}</strong> is a unifier for these atoms and applying this substitution, and both expressions will be identical.</p>
<ul class="points">
<li>The UNIFY algorithm is used for unification, which takes two atomic sentences and returns a unifier for those sentences (If any exist).</li>
<li>Unification is a key component of all first-order inference algorithms.</li>
<li>It returns fail if the expressions do not match with each other.</li>
<li>The substitution variables are called Most General Unifier or MGU. </li>
</ul>
<p><strong>E.g.</strong> Let's say there are two different expressions, <strong>P(x, y), and P(a, f(z))</strong>. </p>
<p>In this example, we need to make both above statements identical to each other. For this, we will perform the substitution. </p>
<p>            P(x, y)......... (i)<br/>
            P(a, f(z))......... (ii)</p>
<ul class="points">
<li>Substitute x with a, and y with f(z) in the first expression, and it will be represented as <strong>a/x</strong> and f(z)/y.</li>
<li>With both the substitutions, the first expression will be identical to the second expression and the substitution set will be: <strong>[a/x, f(z)/y]</strong>.</li>
</ul>
<h2 class="h2">Conditions for Unification: </h2>
<p><strong>Following are some basic conditions for unification:</strong></p>
<ul class="points">
<li>Predicate symbol must be same, atoms or expression with different predicate symbol can never be unified.</li>
<li>Number of Arguments in both expressions must be identical. </li>
<li>Unification will fail if there are two similar variables present in the same expression.</li>
</ul>
<h2 class="h2">Unification Algorithm:</h2>
<p><strong>Algorithm: Unify(Ψ<sub>1</sub>, Ψ<sub>2</sub>) </strong></p>
<div class="codeblock"><pre>
Step. 1: If Ψ<sub>1</sub> or Ψ<sub>2</sub> is a variable or constant, then:
	a) If Ψ<sub>1</sub> or Ψ<sub>2</sub> are identical, then return NIL. 
	b) Else if Ψ<sub>1</sub>is a variable, 
		a. then if Ψ<sub>1</sub> occurs in Ψ<sub>2</sub>, then return FAILURE
		b. Else return { (Ψ<sub>2</sub>/ Ψ<sub>1</sub>)}.
	c) Else if Ψ<sub>2</sub> is a variable, 
		a. If Ψ<sub>2</sub> occurs in Ψ<sub>1</sub> then return FAILURE,
		b. Else return {( Ψ<sub>1</sub>/ Ψ<sub>2</sub>)}. 
	d) Else return FAILURE. 
Step.2: If the initial Predicate symbol in Ψ<sub>1</sub> and Ψ<sub>2</sub> are not same, then return FAILURE.
Step. 3: IF Ψ<sub>1</sub> and Ψ<sub>2</sub> have a different number of arguments, then return FAILURE.
Step. 4: Set Substitution set(SUBST) to NIL. 
Step. 5: For i=1 to the number of elements in Ψ<sub>1</sub>. 
	a) Call Unify function with the ith element of Ψ<sub>1</sub> and ith element of Ψ<sub>2</sub>, and put the result into S.
	b) If S = failure then returns Failure
	c) If S ≠ NIL then do,
		a. Apply S to the remainder of both L1 and L2.
		b. SUBST= APPEND(S, SUBST). 
Step.6: Return SUBST. 
</pre></div>
<h2 class="h2">Implementation of the Algorithm</h2>
<p><strong>Step.1:</strong> Initialize the substitution set to be empty.</p>
<p><strong>Step.2:</strong> Recursively unify atomic sentences:</p>
<ol class="pointsa">
<li>Check for Identical expression match.</li>
<li>If one expression is a variable v<sub>i</sub>, and the other is a term t<sub>i</sub> which does not contain variable v<sub>i</sub>, then:
<ol class="pointsa">
<li>Substitute t<sub>i</sub> / v<sub>i</sub> in the existing substitutions </li>
<li>Add t<sub>i</sub> /v<sub>i</sub> to the substitution setlist.</li>
<li>If both the expressions are functions, then function name must be similar, and the number of arguments must be the same in both the expression. </li>
</ol></li>
</ol>
<p class="pq"><strong>For each pair of the following atomic sentences find the most general unifier (If exist).</strong></p>
<p><strong>1. Find  the MGU of {p(f(a), g(Y)) and p(X, X)} </strong></p>
<p>            Sol: S<sub>0</sub> =&gt;  Here, Ψ<sub>1</sub> = p(f(a), g(Y)), and  Ψ<sub>2</sub> = p(X, X)<br/>
                  SUBST θ= {f(a) / X}<br/>
                  S1 =&gt; Ψ<sub>1</sub> = p(f(a), g(Y)), and  Ψ<sub>2</sub> = p(f(a), f(a))<br/>
                  SUBST θ= {f(a) / g(y)}, <strong>Unification failed</strong>. </p>
<p>Unification is not possible for these expressions.</p>
<p><strong>2. Find the MGU of {p(b, X, f(g(Z))) and p(Z, f(Y), f(Y))}</strong></p>
<p>Here,  Ψ<sub>1</sub> = p(b, X, f(g(Z))) , and Ψ<sub>2</sub> = p(Z, f(Y), f(Y))<br/>
S<sub>0</sub>  =&gt; { p(b, X, f(g(Z)));  p(Z, f(Y), f(Y))}<br/>
SUBST θ={b/Z}</p>
<p>S<sub>1</sub>  =&gt; { p(b, X, f(g(b)));  p(b, f(Y), f(Y))}<br/>
SUBST θ={f(Y) /X}</p>
<p>S<sub>2</sub>  =&gt; { p(b, f(Y), f(g(b)));  p(b, f(Y), f(Y))}<br/>
SUBST θ=  {g(b) /Y}</p>
<p>S<sub>2</sub>  =&gt; { p(b, f(g(b)), f(g(b));  p(b, f(g(b)), f(g(b))} <strong>Unified Successfully.<br/>
And Unifier = { b/Z, f(Y) /X , g(b) /Y}</strong>.</p>
<p><strong>3. Find the MGU of {p (X, X), and p (Z, f(Z))}</strong></p>
<p>Here,  Ψ<sub>1</sub> = {p (X, X), and Ψ<sub>2</sub> = p (Z, f(Z))<br/>
S<sub>0</sub>  =&gt;  {p (X, X),  p (Z, f(Z))}<br/>
SUBST θ=  {X/Z}<br/>
              S1  =&gt;  {p (Z, Z),  p (Z, f(Z))}<br/>
SUBST θ=  {f(Z) / Z},  <strong>Unification Failed</strong>.</p>
<p><strong>Hence, unification is not possible for these expressions.</strong></p>
<p><strong>4. Find the MGU of UNIFY(prime (11), prime(y))</strong></p>
<p>Here,  Ψ<sub>1</sub> = {prime(11) , and Ψ<sub>2</sub> = prime(y)}<br/>
S<sub>0</sub>  =&gt;  {prime(11) , prime(y)}<br/>
SUBST θ=  {11/y}</p>
<p>S<sub>1</sub> =&gt;  {prime(11) , prime(11)} , <strong>Successfully unified.</strong><br/>
              <strong>Unifier: {11/y}.</strong></p>
<p><strong>5. Find the MGU of Q(a, g(x, a), f(y)), Q(a, g(f(b), a), x)}</strong></p>
<p>Here,  Ψ<sub>1</sub> = Q(a, g(x, a), f(y)), and Ψ<sub>2</sub> = Q(a, g(f(b), a), x)<br/>
S<sub>0</sub>  =&gt;  {Q(a, g(x, a), f(y));  Q(a, g(f(b), a), x)}<br/>
SUBST θ=  {f(b)/x}<br/>
S<sub>1</sub>  =&gt;  {Q(a, g(f(b), a), f(y));  Q(a, g(f(b), a), f(b))}</p>
<p>SUBST θ=  {b/y}<br/>
S<sub>1</sub>  =&gt;  {Q(a, g(f(b), a), f(b));  Q(a, g(f(b), a), f(b))}, <strong>Successfully Unified.</strong></p>
<p><strong>Unifier: [a/a, f(b)/x, b/y].</strong></p>
<p><strong>6. UNIFY(knows(Richard, x), knows(Richard, John))</strong></p>
<p>Here, Ψ<sub>1</sub> = knows(Richard, x), and Ψ<sub>2</sub> = knows(Richard, John)<br/>
S<sub>0</sub>  =&gt;  { knows(Richard, x);  knows(Richard, John)}<br/>
SUBST θ= {John/x}<br/>
S<sub>1</sub> =&gt;  { knows(Richard, John);  knows(Richard, John)}, <strong>Successfully Unified.</strong><br/>
<strong>Unifier: {John/x}.</strong></p>
<h1 class="h1">Resolution in FOL</h1>
<h2 class="h2">Resolution</h2>
<p>Resolution is a theorem proving technique that proceeds by building refutation proofs, i.e., proofs by contradictions. It was invented by a Mathematician John Alan Robinson in the year 1965.</p>
<p>Resolution is used, if there are various statements are given, and we need to prove a conclusion of those statements. Unification is a key concept in proofs by resolutions. Resolution is a single inference rule which can efficiently operate on the <strong>conjunctive normal form or clausal form</strong>.</p>
<p><strong>Clause</strong>: Disjunction of literals (an atomic sentence) is called a <strong>clause</strong>. It is also known as a unit clause.</p>
<p><strong>Conjunctive Normal Form</strong>: A sentence represented as a conjunction of clauses is said to be <strong>conjunctive normal form</strong> or <strong>CNF</strong>.</p>
<h4 class="n">Note: To better understand this topic, firstly learns the FOL in AI. </h4>
<h2 class="h2">The resolution inference rule:</h2>
<p>The resolution rule for first-order logic is simply a lifted version of the propositional rule. Resolution can resolve two clauses if they contain complementary literals, which are assumed to be standardized apart so that they share no variables. </p>
<img alt="Resolution in FOL" src="https://static.javatpoint.com/tutorial/ai/images/ai-resolution-in-first-order-logic.png"/>
<p>Where <strong>l<sub>i</sub></strong> and <strong>m<sub>j</sub></strong> are complementary literals.</p>
<p>This rule is also called the <strong>binary resolution rule</strong> because it only resolves exactly two literals. </p>
<h3 class="h3">Example: </h3>
<p>We can resolve two clauses which are given below:</p>
<p><strong>[Animal (g(x) V Loves (f(x), x)]       and       [￢ Loves(a, b) V  ￢Kills(a, b)] </strong></p>
<p>Where two complimentary literals are: <strong>Loves (f(x), x) and ￢ Loves (a, b) </strong></p>
<p>These literals can be unified with unifier <strong>θ= [a/f(x), and b/x] </strong>, and it will generate a resolvent clause:</p>
<p><strong>[Animal (g(x) V ￢ Kills(f(x), x)]. </strong></p>
<h2 class="h2">Steps for Resolution:</h2>
<ol class="points">
<li>Conversion of facts into first-order logic.</li>
<li>Convert FOL statements  into CNF</li>
<li>Negate the statement which needs to prove (proof by contradiction)</li>
<li>Draw resolution graph (unification). </li>
</ol>
<p>To better understand all the above steps, we will take an example in which we will apply resolution.</p>
<h3 class="h3">Example:</h3>
<ol class="pointsa">
<li><strong>John likes all kind of food.</strong></li>
<li><strong>Apple and vegetable are food</strong></li>
<li><strong>Anything anyone eats and not killed is food.</strong></li>
<li><strong>Anil eats peanuts and still alive</strong></li>
<li><strong>Harry eats everything that Anil eats.</strong><br/>
<strong>Prove by resolution that:</strong></li>
<li><strong>John likes peanuts.</strong> </li>
</ol>
<p class="pq"><strong>Step-1: Conversion of Facts into FOL</strong></p>
<p>In the first step we will convert all the given statements into its first order logic. </p>
<img alt="Resolution in FOL" src="https://static.javatpoint.com/tutorial/ai/images/ai-resolution-in-first-order-logic2.png"/>
<p class="pq"><strong>Step-2: Conversion of FOL into CNF</strong></p>
<p>In First order logic resolution, it is required to convert the FOL into CNF as CNF form makes easier for resolution proofs. </p>
<ul class="points">
<li><strong>Eliminate all implication (→) and rewrite</strong>
<ol class="pointsa">
<li>∀x ¬ food(x) V likes(John, x)</li>
<li>food(Apple) Λ food(vegetables)</li>
<li>∀x ∀y ¬ [eats(x, y) Λ ¬ killed(x)] V food(y)</li>
<li>eats (Anil, Peanuts) Λ alive(Anil)</li>
<li>∀x ¬ eats(Anil, x) V  eats(Harry, x)</li>
<li>∀x¬  [¬ killed(x) ] V  alive(x)</li>
<li>∀x  ¬ alive(x) V ¬ killed(x)</li>
<li>likes(John, Peanuts). </li>
</ol></li>
<li><strong>Move negation (¬)inwards and rewrite </strong>
<ol class="pointsa">
<li>∀x ¬ food(x) V likes(John, x)</li>
<li>food(Apple) Λ food(vegetables)</li>
<li>∀x ∀y ¬ eats(x, y) V killed(x) V food(y)</li>
<li>eats (Anil, Peanuts) Λ alive(Anil)</li>
<li>∀x ¬ eats(Anil, x) V  eats(Harry, x)</li>
<li>∀x ¬killed(x) ] V alive(x)</li>
<li>∀x  ¬ alive(x) V ¬ killed(x)</li>
<li>likes(John, Peanuts). </li>
</ol></li>
<li><strong>Rename variables  or standardize variables </strong>
<ol class="pointsa">
<li>∀x ¬ food(x) V likes(John, x)</li>
<li>food(Apple) Λ food(vegetables)</li>
<li>∀y ∀z ¬ eats(y, z) V killed(y) V food(z)</li>
<li>eats (Anil, Peanuts) Λ alive(Anil)</li>
<li>∀w¬ eats(Anil, w) V  eats(Harry, w)</li>
<li>∀g ¬killed(g) ] V alive(g)</li>
<li>∀k  ¬ alive(k) V ¬ killed(k)</li>
<li>likes(John, Peanuts). </li>
</ol></li>
<li><strong>Eliminate existential instantiation quantifier by elimination. </strong><br/>
In this step, we will eliminate existential quantifier ∃, and this process is known as <strong>Skolemization</strong>. But in this example problem since there is no existential quantifier so all the statements will remain same in this step. </li>
<li><strong>Drop Universal quantifiers.</strong><br/>
In this step we will drop all universal quantifier since all the statements are not implicitly quantified so we don't need it. 
<ol class="pointsa">
<li>¬ food(x) V likes(John, x)</li>
<li>food(Apple)</li>
<li>food(vegetables)</li>
<li>¬ eats(y, z) V killed(y) V food(z)</li>
<li>eats (Anil, Peanuts) </li>
<li>alive(Anil)</li>
<li>¬ eats(Anil, w) V  eats(Harry, w)</li>
<li>killed(g) V alive(g)</li>
<li>¬ alive(k)  V ¬ killed(k)</li>
<li>likes(John, Peanuts).</li>
</ol></li>
</ul>
<h4 class="n">Note: Statements "food(Apple) Λ food(vegetables)" and "eats (Anil, Peanuts) Λ alive(Anil)" can be written in two separate statements.</h4>
<ul class="points">
<li><strong>Distribute conjunction ∧ over disjunction ¬.</strong><br/>
This step will not make any change in this problem. </li>
</ul>
<p class="pq"><strong>Step-3: Negate the statement to be proved </strong></p>
<p>In this statement, we will apply negation to the conclusion statements, which will be written as ¬likes(John, Peanuts)</p>
<p class="pq"><strong>Step-4: Draw Resolution graph:</strong></p>
<p>Now in this step, we will solve the problem by resolution tree using substitution. For the above problem, it will be given as follows: </p>
<img alt="Resolution in FOL" src="https://static.javatpoint.com/tutorial/ai/images/ai-resolution-in-first-order-logic3.png"/>
<p>Hence the negation of the conclusion has been proved as a complete contradiction with the given set of statements. </p>
<h2 class="h2">Explanation of Resolution graph:</h2>
<ul class="points">
<li>In the first step of resolution graph, <strong>¬likes(John, Peanuts) </strong>,  and <strong>likes(John, x) </strong>  get resolved(canceled) by substitution of <strong>{Peanuts/x}</strong>, and we are left with <strong>¬ food(Peanuts) </strong></li>
<li>In the second step of the resolution graph, <strong>¬ food(Peanuts) </strong>, and  <strong>food(z) </strong>  get resolved (canceled) by substitution of <strong>{ Peanuts/z}</strong>, and we are left with  <strong>¬ eats(y, Peanuts) V killed(y) </strong>.</li>
<li>In the third step of the resolution graph, <strong>¬ eats(y, Peanuts) </strong> and <strong>eats (Anil, Peanuts) </strong> get resolved by substitution <strong>{Anil/y}</strong>, and we are left with <strong>Killed(Anil) </strong>.</li>
<li>In the fourth step of the resolution graph, <strong>Killed(Anil) </strong>  and <strong>¬ killed(k) </strong> get resolve by substitution <strong>{Anil/k}</strong>, and we are left with <strong>¬ alive(Anil) </strong>.</li>
<li>In the last step of the resolution graph <strong>¬ alive(Anil) </strong> and <strong>alive(Anil) </strong> get resolved.</li>
</ul>
<h1 class="h1">Forward Chaining and backward chaining in AI</h1>
<p>In artificial intelligence, forward and backward chaining is one of the important topics, but before understanding forward and backward chaining lets first understand that from where these two terms came.</p>
<h2 class="h2">Inference engine:</h2>
<p>The inference engine is the component of the intelligent system in artificial intelligence, which applies logical rules to the knowledge base to infer new information from known facts. The first inference engine was part of the expert system.   
Inference engine commonly proceeds in two modes, which are:</p>
<ol class="pointsa">
<li><strong>Forward chaining</strong></li>
<li><strong>Backward chaining</strong></li>
</ol>
<p><strong>Horn Clause and Definite clause:</strong></p>
<p>Horn clause and definite clause are the forms of sentences, which enables knowledge base to use a more restricted and efficient inference algorithm. Logical inference algorithms use forward and backward chaining approaches, which require KB in the form of the <strong>first-order definite clause</strong>.</p>
<p><strong>Definite clause:</strong> A clause which is a disjunction of literals with <strong>exactly one positive literal</strong> is known as a definite clause or strict horn clause.</p>
<p><strong>Horn clause:</strong> A clause which is a disjunction of literals with <strong>at most one positive literal</strong> is known as horn clause. Hence all the definite clauses are horn clauses.</p>
<p><strong>Example: (¬ p V  ¬ q V  k)</strong>. It has only one positive literal k.</p>
It is equivalent to p ∧  q → k.</td></tr></table></div></div></div></div></div></body></html>
<h2 class="h2">A. Forward Chaining</h2>
<p>Forward chaining is also known as a forward deduction or forward reasoning method when using an inference engine.  Forward chaining is a form of reasoning which start with atomic sentences in the knowledge base and applies inference rules (Modus Ponens) in the forward direction to extract more data until a goal is reached.</p>
<p>The Forward-chaining algorithm starts from known facts, triggers all rules whose premises are satisfied, and add their conclusion to the known facts. This process repeats until the problem is solved.</p>
<p><strong>Properties of Forward-Chaining: </strong></p>
<ul class="points">
<li>It is a down-up approach, as it moves from bottom to top.</li>
<li>It is a process of making a conclusion based on known facts or data, by starting from the initial state and reaches the goal state.</li>
<li>Forward-chaining approach is also called as data-driven as we reach to the goal using available data.</li>
<li>Forward -chaining approach is commonly used in the expert system, such as CLIPS, business, and production rule systems.</li>
</ul>
<p>Consider the following famous example which we will use in both approaches:</p>
<h3 class="h3">Example: </h3>
<p><strong>"As per the law, it is a crime for an American to sell weapons to hostile nations. Country A, an enemy of America, has some missiles, and all the missiles were sold to it by Robert, who is an American citizen."</strong></p>
<p>Prove that <strong>"Robert is criminal."</strong></p>
<p>To solve the above problem, first, we will convert all the above facts into first-order definite clauses, and then we will use a forward-chaining algorithm to reach the goal.</p>
<h3 class="h3">Facts Conversion into FOL: </h3>
<ul class="points">
<li>It is a crime for an American to sell weapons to hostile nations. (Let's say p, q, and r are variables)<br/>
<strong>American (p) ∧ weapon(q) ∧ sells (p, q, r) ∧ hostile(r) → Criminal(p)       ...(1)</strong></li>
<li>Country A has some missiles. 
<strong>?p Owns(A, p) ∧ Missile(p)</strong>. It can be written in two definite clauses by using Existential Instantiation, introducing new Constant T1. <br/>
<strong>Owns(A, T1)             ......(2)</strong><br/>
<strong>Missile(T1)             .......(3)</strong></li>
<li>All of the missiles were sold to country A by Robert.<br/>
<strong>?p Missiles(p) ∧ Owns (A, p)  → Sells (Robert, p, A)       ......(4)</strong></li>
<li>Missiles are weapons.<br/>
<strong>Missile(p) → Weapons (p)             .......(5)</strong></li>
<li>Enemy of America is known as hostile.<br/>
<strong>Enemy(p, America) →Hostile(p)             ........(6)</strong></li>
<li>Country A is an enemy of America.<br/>
<strong>Enemy (A, America)             .........(7)</strong></li>
<li>Robert is American<br/>
<strong>American(Robert).             ..........(8)</strong></li>
</ul>
<h2 class="h2">Forward chaining proof:</h2>
<p><strong>Step-1:</strong></p>
<p>In the first step we will start with the known facts and will choose the sentences which do not have implications, such as: <strong>American(Robert), Enemy(A, America), Owns(A, T1), and Missile(T1)</strong>. All these facts will be represented as below.</p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai.png"/>
<p><strong>Step-2:</strong></p>
<p>At the second step, we will see those facts which infer from available facts and with satisfied premises.</p>
<p>Rule-(1) does not satisfy premises, so it will not be added in the first iteration.</p>
<p>Rule-(2) and (3) are already added.</p>
<p>Rule-(4) satisfy with the substitution {p/T1}, <strong>so Sells (Robert, T1, A)</strong> is added, which infers from the conjunction of Rule (2) and (3).</p>
<p>Rule-(6) is satisfied with the substitution(p/A), so Hostile(A) is added and which infers from Rule-(7).</p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai2.png"/>
<p><strong>Step-3: </strong></p>
<p>At step-3, as we can check Rule-(1) is satisfied with the substitution <strong>{p/Robert, q/T1, r/A}, so we can add Criminal(Robert)</strong> which infers all the available facts. And hence we reached our goal statement. </p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai3.png"/>
<p><strong>Hence it is proved that Robert is Criminal using forward chaining approach.</strong></p>
<h2 class="h2">B. Backward Chaining:</h2>
<p>Backward-chaining is also known as a backward deduction or backward reasoning method when using an inference engine.  A backward chaining algorithm is a form of reasoning, which starts with the goal and works backward, chaining through rules to find known facts that support the goal.</p>
<p><strong>Properties of backward chaining:</strong></p>
<ul class="points">
<li>It is known as a top-down approach.</li>
<li>Backward-chaining is based on modus ponens inference rule.</li>
<li>In backward chaining, the goal is broken into sub-goal or sub-goals to prove the facts true.</li>
<li>It is called a goal-driven approach, as a list of goals decides which rules are selected and used.</li>
<li>Backward -chaining algorithm is used in game theory, automated theorem proving tools, inference engines, proof assistants, and various AI applications.</li>
<li>The backward-chaining method mostly used a <strong>depth-first search</strong> strategy for proof.</li>
</ul>
<h3 class="h3">Example:</h3>
<p>In backward-chaining, we will use the same above example, and will rewrite all the rules.</p>
<ul class="points">
<li><strong>American (p) ∧ weapon(q) ∧ sells (p, q, r) ∧ hostile(r) → Criminal(p)  ...(1)</strong><br/>
<strong>Owns(A, T1)                 ........(2)</strong></li>
<li><strong>Missile(T1)</strong></li>
<li><strong>?p Missiles(p) ∧ Owns (A, p)  → Sells (Robert, p, A)           ......(4) </strong></li>
<li><strong>Missile(p) → Weapons (p)                 .......(5)</strong></li>
<li><strong>Enemy(p, America) →Hostile(p)                 ........(6)</strong></li>
<li><strong>Enemy (A, America)                 .........(7)</strong></li>
<li><strong>American(Robert).                 ..........(8)</strong></li>
</ul>
<h2 class="h2">Backward-Chaining proof:</h2>
<p>In Backward chaining, we will start with our goal predicate, which is <strong>Criminal(Robert)</strong>, and then infer further rules.</p>
<p><strong>Step-1:</strong></p>
<p>At the first step,  we will take the goal fact. And from the goal fact, we will infer other facts, and at last, we will prove those facts true. So our goal fact is "Robert is Criminal," so following is the predicate of it.</p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai4.png"/>
<p><strong>Step-2:</strong></p>
<p>At the second step, we will infer other facts form goal fact which satisfies the rules. So as we can see in Rule-1, the goal predicate Criminal (Robert)  is present with substitution {Robert/P}. So we will add all the conjunctive facts below the first level and will replace p with Robert.</p>
<p><strong>Here we can see American (Robert) is a fact, so it is proved here.</strong></p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai5.png"/>
<p><strong>Step-3:</strong>t At step-3,  we will extract further fact Missile(q) which infer from Weapon(q), as it satisfies Rule-(5). Weapon (q) is also true with the substitution of a constant T1 at q. </p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai6.png"/>
<p><strong>Step-4:</strong></p>
<p>At step-4, we can infer facts Missile(T1) and Owns(A, T1) form Sells(Robert, T1, r) which satisfies the <strong>Rule- 4</strong>, with the substitution of A in place of r. So these two statements are proved here. </p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai7.png"/>
<p><strong>Step-5: </strong></p>
<p>At step-5, we can infer the fact <strong>Enemy(A, America)</strong> from <strong>Hostile(A)</strong> which satisfies Rule- 6. And hence all the statements are proved true using backward chaining. </p>
<img alt="Forward Chaining and backward chaining in AI" src="https://static.javatpoint.com/tutorial/ai/images/forward-chaining-and-backward-chaining-in-ai8.png"/>
<h1 class="h1">Difference between backward chaining and forward chaining</h1>
<p><strong>Following is the difference between the forward chaining and backward chaining:</strong></p>
<ul class="points">
<li>Forward chaining as the name suggests, start from the known facts and move forward by applying inference rules to extract more data, and it continues until it reaches to the goal, whereas backward chaining starts from the goal, move backward by using inference rules to determine the facts that satisfy the goal.</li>
<li>Forward chaining is called a <strong>data-driven</strong> inference technique, whereas backward chaining is called a <strong>goal-driven</strong> inference technique.</li>
<li>Forward chaining is known as the <strong>down-up</strong> approach, whereas backward chaining is known as a <strong>top-down</strong> approach.</li>
<li>Forward chaining uses <strong>breadth-first search</strong> strategy, whereas backward chaining uses <strong>depth-first search</strong> strategy.</li>
<li>Forward and backward chaining both applies <strong>Modus ponens</strong> inference rule.</li>
<li>Forward chaining can be used for tasks such as <strong>planning, design process monitoring, diagnosis, and classification</strong>, whereas backward chaining can be used for <strong>classification and diagnosis tasks</strong>.</li>
<li>Forward chaining can be like an exhaustive search, whereas backward chaining tries to avoid the unnecessary path of reasoning.</li>
<li>In forward-chaining there can be various ASK questions from the knowledge base, whereas in backward chaining there can be fewer ASK questions.</li>
<li>Forward chaining is slow as it checks for all the rules, whereas backward chaining is fast as it checks few required rules only. </li>
</ul>
<table class="alt">
<tr>
<th>S. No.</th>
<th>Forward Chaining</th>
<th>Backward Chaining</th>
</tr>
<tr>
<td>1.</td>
<td>Forward chaining starts from known facts and applies inference rule to extract more data unit it reaches to the goal.</td>
<td>Backward chaining starts from the goal and works backward through inference rules to find the required facts that support the goal.</td>
</tr>
<tr>
<td>2.</td>
<td>It is a bottom-up approach</td>
<td>It is a top-down approach</td>
</tr>
<tr>
<td>3.</td>
<td>Forward chaining is known as data-driven inference technique as we reach to the goal using the available data.</td>
<td>Backward chaining is known as goal-driven technique as we start from the goal and divide into sub-goal to extract the facts.</td>
</tr>
<tr>
<td>4.</td>
<td>Forward chaining reasoning applies a breadth-first search strategy.</td>
<td>Backward chaining reasoning applies a depth-first search strategy.</td>
</tr>
<tr>
<td>5.</td>
<td>Forward chaining tests for all the available rules</td>
<td>Backward chaining only tests for few required rules.</td>
</tr>
<tr>
<td>6.</td>
<td>Forward chaining is suitable for the planning, monitoring, control, and interpretation application.</td>
<td>Backward chaining is suitable for diagnostic, prescription, and debugging application.</td>
</tr>
<tr>
<td>7.</td>
<td>Forward chaining can generate an infinite number of possible conclusions.</td>
<td>Backward chaining generates a finite number of possible conclusions.</td>
</tr>
<tr>
<td>8.</td>
<td>It operates in the forward direction.</td>
<td>It operates in the backward direction.</td>
</tr>
<tr>
<td>9.</td>
<td>Forward chaining is aimed for any conclusion.</td>
<td>Backward chaining is only aimed for the required data.</td>
</tr>
</table>
<h1 class="h1">Reasoning in Artificial intelligence</h1>
<p>In previous topics, we have learned various ways of knowledge representation in artificial intelligence. Now we will learn the various ways to reason on this knowledge using different logical schemes. </p>
<h2 class="h2">Reasoning:</h2>
<p>The reasoning is the mental process of deriving logical conclusion and making predictions from available knowledge, facts, and beliefs. Or we can say, "<strong>Reasoning is a way to infer facts from existing data</strong>." It is a general process of thinking rationally, to find valid conclusions.</p>
<p>In artificial intelligence, the reasoning is essential so that the machine can also think rationally as a human brain, and can perform like a human.</p>
<h2 class="h2">Types of Reasoning</h2>
<p>In artificial intelligence, reasoning can be divided into the following categories:</p>
<ul class="points">
<li>Deductive reasoning</li>
<li>Inductive reasoning</li>
<li>Abductive reasoning</li>
<li>Common Sense Reasoning</li>
<li>Monotonic Reasoning</li>
<li>Non-monotonic Reasoning</li>
</ul>
<h4 class="n">Note: Inductive and deductive reasoning are the forms of propositional logic. </h4>
<h3 class="h3">1. Deductive reasoning:</h3>
<p>Deductive reasoning is deducing new information from logically related known information. It is the form of valid reasoning, which means the argument's conclusion must be true when the premises are true.</p>
<p>Deductive reasoning is a type of propositional logic in AI, and it requires various rules and facts. It is sometimes referred to as top-down reasoning, and contradictory to inductive reasoning.</p>
<p>In deductive reasoning, the truth of the premises guarantees the truth of the conclusion.</p>
<p>Deductive reasoning mostly starts from the general premises to the specific conclusion, which can be explained as below example.</p>
<p class="pq"><strong>Example:</strong></p>
<p><strong>Premise-1: All the human eats veggies</strong></p>
<p><strong>Premise-2: Suresh is human. </strong></p>
<p><strong>Conclusion: Suresh eats veggies.</strong></p>
<p>The general process of deductive reasoning is given below: </p>
<img alt="Reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/deductive-reasoning.png"/>
<h3 class="h3">2. Inductive Reasoning: </h3>
<p>Inductive reasoning is a form of reasoning to arrive at a conclusion using limited sets of facts by the process of generalization. It starts with the series of specific facts or data and reaches to a general statement or conclusion.</p>
<p>Inductive reasoning is a type of propositional logic, which is also known as cause-effect reasoning or bottom-up reasoning.</p>
<p>In inductive reasoning, we use historical data or various premises to generate a generic rule, for which premises support the conclusion.</p>
<p>In inductive reasoning, premises provide probable supports to the conclusion, so the truth of premises does not guarantee the truth of the conclusion.</p>
<p class="pq"><strong>Example:</strong></p>
<p><strong>Premise: All of the pigeons we have seen in the zoo are white.</strong></p>
<p><strong>Conclusion: Therefore, we can expect all the pigeons to be white.</strong></p>
<img alt="Reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/inductive-reasoning.png"/>
<h3 class="h3">3. Abductive reasoning:</h3>
<p>Abductive reasoning is a form of logical reasoning which starts with single or multiple observations then seeks to find the most likely explanation or conclusion for the observation.</p>
<p>Abductive reasoning is an extension of deductive reasoning, but in abductive reasoning, the premises do not guarantee the conclusion.</p>
<p class="pq"><strong>Example:</strong></p>
<p><strong>Implication:</strong> Cricket ground is wet if it is raining</p>
<p><strong>Axiom:</strong> Cricket ground is wet.</p>
<p>Conclusion It is raining.</p>
<h3 class="h3">4. Common Sense Reasoning</h3>
<p>Common sense reasoning is an informal form of reasoning, which can be gained through experiences.</p>
<p>Common Sense reasoning simulates the human ability to make presumptions about events which occurs on every day.</p>
<p>It relies on good judgment rather than exact logic and operates on <strong>heuristic knowledge</strong> and <strong>heuristic rules</strong>.</p>
<p class="pq"><strong>Example:</strong></p>
<ol class="points">
<li><strong>One person can be at one place at a time.</strong></li>
<li><strong>If I put my hand in a fire, then it will burn.</strong></li>
</ol>
<p>The above two statements are the examples of common sense reasoning which a human mind can easily understand and assume. </p>
<h3 class="h3">5. Monotonic Reasoning:</h3>
<p>In monotonic reasoning, once the conclusion is taken, then it will remain the same even if we add some other information to existing information in our knowledge base. In monotonic reasoning, adding knowledge does not decrease the set of prepositions that can be derived.</p>
<p>To solve monotonic problems, we can derive the valid conclusion from the available facts only, and it will not be affected by new facts.</p>
<p>Monotonic reasoning is not useful for the real-time systems, as in real time, facts get changed, so we cannot use monotonic reasoning.</p>
<p>Monotonic reasoning is used in conventional reasoning systems, and a logic-based system is monotonic.</p>
<p>Any theorem proving is an example of monotonic reasoning.</p>
<p class="pq"><strong>Example:</strong></p>
<ul class="points">
<li><strong>Earth revolves around the Sun. </strong></li>
</ul>
<p>It is a true fact, and it cannot be changed even if we add another sentence in knowledge base like, "The moon revolves around the earth" Or "Earth is not round," etc. </p>
<h3 class="h4">Advantages of Monotonic Reasoning:</h3>
<ul class="points">
<li>In monotonic reasoning, each old proof will always remain valid.</li>
<li>If we deduce some facts from available facts, then it will remain valid for always. </li>
</ul>
<h3 class="h4">Disadvantages of Monotonic Reasoning:</h3>
<ul class="points">
<li>We cannot represent the real world scenarios using Monotonic reasoning.</li>
<li>Hypothesis knowledge cannot be expressed with monotonic reasoning, which means facts should be true.</li>
<li>Since we can only derive conclusions from the old proofs, so new knowledge from the real world cannot be added. </li>
</ul>
<h3 class="h3">6. Non-monotonic Reasoning</h3>
<p>In Non-monotonic reasoning, some conclusions may be invalidated if we add some more information to our knowledge base.</p>
<p>Logic will be said as non-monotonic if some conclusions can be invalidated by adding more knowledge into our knowledge base.</p>
<p>Non-monotonic reasoning deals with incomplete and uncertain models.</p>
<p>"Human perceptions for various things in daily life, "is a general example of non-monotonic reasoning.</p>
<p><strong>Example:</strong> Let suppose the knowledge base contains the following knowledge:</p>
<ul class="points">
<li><strong>Birds can fly</strong></li>
<li><strong>Penguins cannot fly</strong></li>
<li><strong>Pitty is a bird</strong></li>
</ul>
<p>So from the above sentences, we can conclude that <strong>Pitty can fly</strong>.</p>
<p>However, if we add one another sentence into knowledge base "<strong>Pitty is a penguin</strong>", which concludes "<strong>Pitty cannot fly</strong>", so it invalidates the above conclusion.</p>
<h3 class="h4">Advantages of Non-monotonic reasoning:</h3></td></tr></table></div></div></div></div></div></body></html>
<ul class="points">
<li>For real-world systems such as Robot navigation, we can use non-monotonic reasoning.</li>
<li>In Non-monotonic reasoning, we can choose probabilistic facts or can make assumptions. </li>
</ul>
<h3 class="h4">Disadvantages of Non-monotonic Reasoning:</h3>
<ul class="points">
<li>In non-monotonic reasoning, the old facts may be invalidated by adding new sentences.</li>
<li>It cannot be used for theorem <strong>proving</strong>. </li>
</ul>
<h1 class="h1">Difference between Inductive and Deductive reasoning</h1>
<p>Reasoning in artificial intelligence has two important forms, Inductive reasoning, and Deductive reasoning. Both reasoning forms have premises and conclusions, but both reasoning are contradictory to each other. Following is a list for comparison between inductive and deductive reasoning:</p>
<ul class="points">
<li>Deductive reasoning uses available facts, information, or knowledge to deduce a valid conclusion, whereas inductive reasoning involves making a generalization from specific facts, and observations.</li>
<li>Deductive reasoning uses a top-down approach, whereas inductive reasoning uses a bottom-up approach.</li>
<li>Deductive reasoning moves from generalized statement to a valid conclusion, whereas Inductive reasoning moves from specific observation to a generalization.</li>
<li>In deductive reasoning, the conclusions are certain, whereas, in Inductive reasoning, the conclusions are probabilistic.</li>
<li>Deductive arguments can be valid or invalid, which means if premises are true, the conclusion must be true, whereas inductive argument can be strong or weak, which means conclusion may be false even if premises are true.</li>
</ul>
<p>The differences between inductive and deductive can be explained using the below diagram on the basis of arguments:</p>
<img alt="Inductive vs Deductive reasoning" src="https://static.javatpoint.com/tutorial/ai/images/inductive-vs-deductive-reasoning.png"/>
<p><strong>Comparison Chart:</strong></p>
<table class="alt">
<tr>
<th>Basis for comparison</th>
<th>Deductive Reasoning</th>
<th>Inductive Reasoning</th>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Deductive reasoning is the form of valid reasoning, to deduce new information or conclusion from known related facts and information.</td>
<td>Inductive reasoning arrives at a conclusion by the process of generalization using specific facts or data.</td>
</tr>
<tr>
<td><strong>Approach</strong></td>
<td>Deductive reasoning follows a top-down approach.</td>
<td>Inductive reasoning follows a bottom-up approach.</td>
</tr>
<tr>
<td><strong>Starts from</strong></td>
<td>Deductive reasoning starts from Premises.</td>
<td>Inductive reasoning starts from the Conclusion.</td>
</tr>
<tr>
<td><strong>Validity</strong></td>
<td>In deductive reasoning conclusion must be true if the premises are true.</td>
<td>In inductive reasoning, the truth of premises does not guarantee the truth of conclusions.</td>
</tr>
<tr>
<td><strong>Usage</strong></td>
<td>Use of deductive reasoning is difficult, as we need facts which must be true.</td>
<td>Use of inductive reasoning is fast and easy, as we need evidence instead of true facts. We often use it in our daily life.</td>
</tr>
<tr>
<td><strong>Process</strong></td>
<td>Theory→ hypothesis→ patterns→confirmation.</td>
<td>Observations-→patterns→hypothesis→Theory.</td>
</tr>
<tr>
<td><strong>Argument</strong></td>
<td>In deductive reasoning, arguments may be valid or invalid.</td>
<td>In inductive reasoning, arguments may be weak or strong.</td>
</tr>
<tr>
<td><strong>Structure</strong></td>
<td>Deductive reasoning reaches from general facts to specific facts.</td>
<td>Inductive reasoning reaches from specific facts to general facts.</td>
</tr>
</table>
<h1 class="h1">Probabilistic reasoning in Artificial intelligence</h1>
<h2 class="h2">Uncertainty:</h2>
<p>Till now, we have learned knowledge representation using first-order logic and propositional logic with certainty, which means we were sure about the predicates. With this knowledge representation, we might write A→B, which means if A is true then B is true, but consider a situation where we are not sure about whether A is true or not then we cannot express this statement, this situation is called uncertainty. </p>
<p>So to represent uncertain knowledge, where we are not sure about the predicates, we need uncertain reasoning or probabilistic reasoning. </p>
<h2 class="h3">Causes of uncertainty:</h2>
<p>Following are some leading causes of uncertainty to occur in the real world.</p>
<ol class="points">
<li>Information occurred from unreliable sources. </li>
<li>Experimental Errors</li>
<li>Equipment fault</li>
<li>Temperature variation</li>
<li>Climate change. </li>
</ol>
<h2 class="h2">Probabilistic reasoning:</h2>
<p>Probabilistic reasoning is a way of knowledge representation where we apply the concept of probability to indicate the uncertainty in knowledge. In probabilistic reasoning, we combine probability theory with logic to handle the uncertainty.</p>
<p>We use probability in probabilistic reasoning because it provides a way to handle the uncertainty that is the result of someone's laziness and ignorance. </p>
<p>In the real world, there are lots of scenarios, where the certainty of something is not confirmed, such as "It will rain today," "behavior of someone for some situations," "A match between two teams or two players." These are probable sentences for which we can assume that it will happen but not sure about it, so here we use probabilistic reasoning. </p>
<p><strong>Need of probabilistic reasoning in AI:</strong></p>
<ul class="points">
<li>When there are unpredictable outcomes. </li>
<li>When specifications or possibilities of predicates becomes too large to handle.</li>
<li>When an unknown error occurs during an experiment.</li>
</ul>
<p>In probabilistic reasoning, there are two ways to solve problems with uncertain knowledge:</p>
<ul class="points">
<li><strong>Bayes' rule</strong></li>
<li><strong>Bayesian Statistics</strong></li>
</ul>
<h4 class="n">Note: We will learn the above two rules in later chapters. </h4>
<p>As probabilistic reasoning uses probability and related terms, so before understanding probabilistic reasoning, let's understand some common terms:</p>
<p><strong>Probability:</strong> Probability can be defined as a chance that an uncertain event will occur. It is the numerical measure of the likelihood that an event will occur. The value of probability always remains between 0 and 1 that represent ideal uncertainties.</p>
<div class="codeblock"><textarea class="java" name="code">
0 ≤ P(A) ≤ 1,   where P(A) is the probability of an event A.
</textarea></div>
<div class="codeblock"><textarea class="java" name="code">
P(A) = 0,  indicates total uncertainty in an event A. 
</textarea></div>
<div class="codeblock"><textarea class="java" name="code">
P(A) =1, indicates total certainty in an event A.  
</textarea></div>
<p>We can find the probability of an uncertain event by using the below formula.</p>
<img alt="Probabilistic reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/probabilistic.png"/>
<ul class="points">
<li>P(¬A) = probability of a not happening event. </li>
<li>P(¬A) + P(A) = 1.</li>
</ul>
<p><strong>Event:</strong> Each possible outcome of a variable is called an event.</p>
<p><strong>Sample space:</strong> The collection of all possible events is called sample space. </p>
<p><strong>Random variables:</strong> Random variables are used to represent the events and objects in the real world. </p>
<p><strong>Prior probability:</strong> The prior probability of an event is probability computed before observing new information.</p>
<p><strong>Posterior Probability:</strong> The probability that is calculated after all evidence or information has taken into account. It is a combination of prior probability and new information. </p>
<h2 class="h3">Conditional probability:</h2>
<p>Conditional probability is a probability of occurring an event when another event has already happened. </p>
<p>Let's suppose, we want to calculate the event A when event B has already occurred, "the probability of A under the conditions of B", it can be written as:</p>
<img alt="Probabilistic reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/probabilistic2.png"/>
<p><strong>Where P(<em>A</em>⋀<em>B</em>)= Joint probability of a and B</strong></p>
<p><strong>P(B)= Marginal probability of B. </strong>
<p>If the probability of A is given and we need to find the probability of B, then it will be given as:</p>
<img alt="Probabilistic reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/probabilistic3.png"/>
<p>It can be explained by using the below Venn diagram, where B is occurred event, so sample space will be reduced to set B, and now we can only calculate event A when event B is already occurred by dividing the probability of  <strong>P(A⋀<em>B</em>) by P( B )</strong>. </p>
<img alt="Probabilistic reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/probabilistic4.png"/>
<p><strong>Example:</strong></p>
<p>In a class, there are 70% of the students who like English and 40% of the students who likes English and mathematics, and then what is the percent of students those who like English also like mathematics?</p>
<p><strong>Solution:</strong></p>
<p>Let, A is an event that a student likes Mathematics</p>
<p>B is an event that a student likes English. </p>
<img alt="Probabilistic reasoning in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/probabilistic5.png"/>
<p><strong>Hence, 57% are the students who like English also like Mathematics. </strong></p>
<h1 class="h1">Bayes' theorem in Artificial intelligence</h1>
<h2 class="h2">Bayes' theorem:</h2>
<p>Bayes' theorem is also known as <strong>Bayes' rule, Bayes' law</strong>, or <strong>Bayesian reasoning</strong>, which determines the probability of an event with uncertain knowledge.</p>
<p>In probability theory, it relates the conditional probability and marginal probabilities of two random events. </p>
<p>Bayes' theorem was named after the British mathematician <strong>Thomas Bayes</strong>. The <strong>Bayesian inference</strong> is an application of Bayes' theorem, which is fundamental to Bayesian statistics. </p>
<p>It is a way to calculate the value of P(B|A) with the knowledge of P(A|B).  </p>
<p>Bayes' theorem allows updating the probability prediction of an event by observing new information of the real world. </p>
<p><strong>Example</strong>: If cancer corresponds to one's age then by using Bayes' theorem, we can determine the probability of cancer more accurately with the help of age. </p>
<p>Bayes' theorem can be derived using product rule and conditional probability of event A with known event B: </p>
<p>As from product rule we can write:</p>
<div class="codeblock"><textarea class="java" name="code">
P(A ⋀ B)= P(A|B) P(B) or
</textarea></div>
<p>Similarly, the probability of event B with known event A:</p>
<div class="codeblock"><textarea class="java" name="code">
P(A ⋀ B)= P(B|A) P(A)
</textarea></div>
<p>Equating right hand side of both the equations, we will get:</p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem.png"/>
<p>The above equation (a) is called as <strong>Bayes' rule</strong> or<strong> Bayes' theorem</strong>. This equation is basic of most modern AI systems for <strong>probabilistic inference</strong>. </p>
<p>It shows the simple relationship between joint and conditional probabilities. Here, </p>
<p>P(A|B) is known as <strong>posterior</strong>, which we need to calculate, and it will be read as Probability of hypothesis A when we have occurred an evidence B. </p>
<p>P(B|A) is called the likelihood, in which we consider that hypothesis is true, then we calculate the probability of evidence. </p>
<p>P(A) is called the <strong>prior probability</strong>, probability of hypothesis before considering the evidence</p>
<p>P(B) is called <strong>marginal probability</strong>, pure probability of an evidence. </p>
<p>In the equation (a), in general, we can write P (B) =  P(A)*P(B|Ai), hence the Bayes' rule can be written as:</p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem2.png"/>
<p>Where A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>,........, A<sub>n</sub> is a set of mutually exclusive and exhaustive events. </p>
<h2 class="h2">Applying Bayes' rule:</h2>
<p>Bayes' rule allows us to compute the single term P(B|A) in terms of P(A|B), P(<em>B</em>), and P(A). This is very useful in cases where we have a good probability of these three terms and want to determine the fourth one. Suppose we want to perceive the effect of some unknown cause, and want to compute that cause, then the Bayes' rule becomes:</p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem3.png"/>
<p><strong>Example-1:</strong></p>
<p><strong>Question: what is the probability that a patient has diseases meningitis with a stiff neck?</strong></p>
<p><strong>Given Data:</strong></p>
<p> A doctor is aware that disease meningitis causes a patient to have a stiff neck, and it occurs 80% of the time. He is also aware of some more facts, which are given as follows:</p>
<ul class="points">
<li>The Known probability that a patient has meningitis disease is 1/30,000.</li>
<li>The Known probability that a patient has a stiff neck is 2%.</li>
</ul>
<p>Let a be the proposition that patient has stiff neck and b be the proposition that patient has meningitis. , so we can calculate the following as:</p>
<p>P(a|b) = 0.8</p>
<p>P(b) = 1/30000</p>
<p>P(a)= .02</p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem4.png"/>
<p>Hence, we can assume that 1 patient out of 750 patients has meningitis disease with a stiff neck. </p>
<p><strong>Example-2:</strong></p>
<p><strong>Question: From a standard deck of playing cards, a single card is drawn. The probability that the card is king is 4/52, then calculate posterior probability P(King|Face), which means the drawn face card is a king card. </strong></p>
<p><strong>Solution:</strong></p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem5.png"/>
<p>P(king): probability that the card is King= 4/52= 1/13</p>
<p>P(face): probability that a card is a face card= 3/13 </p>
<p>P(Face|King): probability of face card when we assume it is a king = 1</p>
<p>Putting all values in equation (i) we will get:</p>
<img alt="Bayes theorem in Artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayes-theorem6.png"/>
<h2 class="h2">Application of Bayes' theorem in Artificial intelligence:</h2>
<p><strong>Following are some applications of Bayes' theorem:</strong></p>
<ul class="points">
<li>It is used to calculate the next step of the robot when the already executed step is given. </li>
<li>Bayes' theorem is helpful in weather forecasting.</li>
<li>It can solve the Monty Hall problem. </li>
</ul>
<h1 class="h1">Bayesian Belief Network in artificial intelligence</h1>
<p>Bayesian belief network is key computer technology for dealing with probabilistic events and to solve a problem which has uncertainty. We can define a Bayesian network as: </p>
<p>"A Bayesian network is a probabilistic graphical model which represents a set of variables and their conditional dependencies using a directed acyclic graph."</p>
<p>It is also called a <strong>Bayes network, belief network, decision network</strong>, or <strong>Bayesian model</strong>.</p>
<p>Bayesian networks are probabilistic, because these networks are built from a <strong>probability distribution</strong>, and also use probability theory for prediction and anomaly detection. </p>
<p>Real world applications are probabilistic in nature, and to represent the relationship between multiple events, we need a Bayesian network. It can also be used in various tasks including <strong>prediction, anomaly detection, diagnostics, automated insight, reasoning, time series prediction</strong>, and <strong>decision making under uncertainty</strong>.</p>
<p>Bayesian Network can be used for building models from data and experts opinions, and it consists of two parts:</p>
<ul class="points">
<li><strong>Directed Acyclic Graph</strong></li>
<li><strong>Table of conditional probabilities.</strong></li>
</ul>
<p>The generalized form of Bayesian network that represents and solve decision problems under uncertain knowledge is known as an <strong>Influence diagram</strong>.</p>
<p><strong>A Bayesian network graph is made up of nodes and Arcs (directed links), where:</strong></p>
<img alt="Bayesian Belief Network" src="https://static.javatpoint.com/tutorial/ai/images/bayesian.jpg"/>
<ul class="points">
<li>Each <strong>node</strong> corresponds to the random variables, and a variable can be <strong>continuous</strong> or <strong>discrete</strong>. </li>
<li><strong>Arc or directed arrows</strong> represent the causal relationship or conditional probabilities between random variables. These directed links or arrows connect the pair of nodes in the graph.<br/>
These links represent that one node directly influence the other node, and if there is no directed link that means that nodes are independent with each other
<ul class="points">
<li><strong>In the above diagram, A, B, C, and D are random variables represented by the nodes of the network graph.</strong></li>
<li><strong>If we are considering node B, which is connected with node A by a directed arrow, then node A is called the parent of Node B.</strong></li>
<li><strong>Node C is independent of node A.</strong></li>
</ul></li>
</ul>
<h4 class="n">Note: The Bayesian network graph does not contain any cyclic graph. Hence, it is known as a <span class="bold">directed acyclic graph or DAG</span>. </h4>
<p>The Bayesian network has mainly two components:</p>
<ul class="points">
<li><strong>Causal Component</strong></li>
<li><strong>Actual numbers</strong></li>
</ul>
<p>Each node in the Bayesian network has condition probability distribution <strong>P(X<sub>i</sub> |Parent(X<sub>i</sub>) )</strong>, which determines the effect of the parent on that node. </p>
<p>Bayesian network is based on Joint probability distribution and conditional probability. So let's first understand the joint probability distribution:</p>
<h2 class="h2">Joint probability distribution:</h2>
<p>If we have variables x1, x2, x3,....., xn, then the probabilities of a different combination of x1, x2, x3.. xn, are known as Joint probability distribution. </p>
<p><strong>P[x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>,....., x<sub>n</sub>]</strong>, it can be written as the following way in terms of the joint probability distribution.</p>
<p><strong>= P[x<sub>1</sub>| x<sub>2</sub>, x<sub>3</sub>,....., x<sub>n</sub>]P[x<sub>2</sub>, x<sub>3</sub>,....., x<sub>n</sub>]</strong></p>
<p><strong>= P[x<sub>1</sub>| x<sub>2</sub>, x<sub>3</sub>,....., x<sub>n</sub>]P[x<sub>2</sub>|x<sub>3</sub>,....., x<sub>n</sub>]....P[x<sub>n-1</sub>|x<sub>n</sub>]P[x<sub>n</sub>].</strong></p>
<p>In general for each variable Xi, we can write the equation as:</p>
<div class="codeblock"><pre>
P(X<sub>i</sub>|X<sub>i-1</sub>,........., X<sub>1</sub>) = P(X<sub>i</sub> |Parents(X<sub>i</sub> ))
</pre></div>
<h2 class="h2">Explanation of Bayesian network: </h2>
<p>Let's understand the Bayesian network through an example by creating a directed acyclic graph:</p>
<p><strong>Example:</strong> Harry installed a new burglar alarm at his home to detect burglary. The alarm reliably responds at detecting a burglary but also responds for minor earthquakes. Harry has two neighbors David and Sophia, who have taken a responsibility to inform Harry at work when they hear the alarm.  David always calls Harry when he hears the alarm, but sometimes he got confused with the phone ringing and calls at that time too.  On the other hand, Sophia likes to listen to high music, so sometimes she misses to hear the alarm. Here we would like to compute the probability of Burglary Alarm. </p>
<p><strong>Problem:</strong></p>
<p><strong>Calculate the probability that alarm has sounded, but there is neither a burglary, nor an earthquake occurred, and David and Sophia both called the Harry.</strong></p>
<p><strong>Solution:</strong></p>
<ul class="points">
<li>The Bayesian network for the above problem is given below. The network structure is showing that burglary and earthquake is the parent node of the alarm and directly affecting the probability of alarm's going off, but David and Sophia's calls depend on alarm probability.</li>
<li>The network is representing that our assumptions do not directly perceive the burglary and also do not notice the minor earthquake, and they also not confer before calling.</li>
<li>The conditional distributions for each node are given as conditional probabilities table or CPT. </li>
<li>Each row in the CPT must be sum to 1 because all the entries in the table represent an exhaustive set of cases for the variable. </li>
<li>In CPT, a boolean variable with k boolean parents contains 2<sup>K</sup>  probabilities. Hence, if there are two parents, then CPT will contain 4 probability values</li>
</ul>
<p><strong>List of all events occurring in this network:</strong></p>
<ul class="points">
<li><strong>Burglary (B)</strong></li>
<li><strong>Earthquake(E)</strong></li>
<li><strong>Alarm(A)</strong></li>
<li><strong>David Calls(D)</strong></li>
<li><strong>Sophia calls(S)</strong></li>
</ul>
<p>We can write the events of problem statement in the form of probability: <strong>P[D, S, A, B, E]</strong>, can rewrite the above probability statement using joint probability distribution:</p>
<p><strong>P[D, S, A, B, E]= P[D | S, A, B, E]. P[S, A, B, E]</strong></p>
<p><strong>=P[D | S, A, B, E]. P[S | A, B, E]. P[A, B, E]</strong></p>
<p><strong>= P [D| A]. P [ S| A, B, E]. P[ A, B, E]</strong></p>
<p><strong>= P[D | A]. P[ S | A]. P[A| B, E].  P[B, E]</strong></p>
<p><strong>= P[D | A ]. P[S | A]. P[A| B, E].  P[B |E]. P[E]</strong></p>
<img alt="Bayesian Belief Network in artificial intelligence" src="https://static.javatpoint.com/tutorial/ai/images/bayesian2.png"/>
<p>Let's take the observed probability for the Burglary and earthquake component:</p>
<p>P(B= True)  = 0.002, which is the probability of burglary. </p>
<p>P(B= False)= 0.998, which is the probability of no burglary. </p>
<p>P(E= True)= 0.001,  which is the probability of a minor earthquake</p>
<p>P(E= False)= 0.999, Which is the probability that an earthquake not occurred. </p>
<p>We can provide the conditional probabilities as per the below tables:</p>
<p><strong>Conditional probability table for Alarm A:</strong></p>
<p>The Conditional probability of Alarm A depends on Burglar and earthquake:</p>
<table class="alt">
<tr>
<th>B</th>
<th>E</th>
<th>P(A= True)</th>
<th>P(A= False)</th>
</tr>
<tr>
<td>True</td>
<td>True</td>
<td>0.94</td>
<td>0.06</td>
</tr>
<tr>
<td>True</td>
<td>False</td>
<td>0.95</td>
<td>0.04</td>
</tr>
<tr>
<td>False </td>
<td>True</td>
<td>0.31</td>
<td>0.69</td>
</tr>
<tr>
<td>False</td>
<td>False</td>
<td>0.001</td>
<td>0.999</td>
</tr>
</table>
<p><strong>Conditional probability table for David Calls:</strong></p>
<p>The Conditional probability of David that he will call depends on the probability of Alarm. </p>
<table class="alt">
<tr>
<th>A</th>
<th>P(D= True)</th>
<th>P(D= False)</th>
</tr>
<tr>
<td>True</td>
<td>0.91</td>
<td>0.09</td>
</tr>
<tr>
<td>False</td>
<td>0.05</td>
<td>0.95</td>
</tr>
</table>
<p><strong>Conditional probability table for Sophia Calls:</strong></p>
<p>The Conditional probability of Sophia that she calls is depending on its Parent Node "Alarm."</p>
<table class="alt">
<tr>
<th>A</th>
<th>P(S= True)</th>
<th>P(S= False)</th>
</tr>
<tr>
<td>True</td>
<td>0.75</td>
<td>0.25</td>
</tr>
<tr>
<td>False</td>
<td>0.02</td>
<td>0.98</td>
</tr>
</table>
<p>From the formula of joint distribution, we can write the problem statement in the form of probability distribution:</p>
<p><strong>P(S, D, A, ¬B, ¬E) = P (S|A) *P (D|A)*P (A|¬B ^ ¬E) *P (¬B) *P (¬E). </strong></p>
<p>=  0.75* 0.91* 0.001* 0.998*0.999	</p>
<p><strong>=  0.00068045.</strong></p>
<p><strong>Hence, a Bayesian network can answer any query about the domain by using Joint distribution. </strong></p>
<p><strong>The semantics of Bayesian Network:</strong></p>
<p>There are two ways to understand the semantics of the Bayesian network, which is given below:</p>
<p><strong>1. To understand the network as the representation of the Joint probability distribution. </strong></p>
<p>It is helpful to understand how to construct the network.</p>
<p><strong>2. To understand the network as an encoding of a collection of conditional independence statements. </strong></p>
<p>It is helpful in designing inference procedure. </p>
<h1 class="h1">Subsets of Artificial Intelligence</h1>
<p><strong>Till now, we have learned about what is AI, and now we will learn in this topic about various subsets of AI. Following are the most common subsets of AI:</strong></p>
<ul class="points">
<li><strong>Machine Learning</strong></li>
<li><strong>Deep Learning</strong></li>
<li><strong>Natural Language processing</strong></li>
<li><strong>Expert System</strong></li>
<li><strong>Robotics</strong></li>
<li><strong>Machine Vision</strong></li>
<li><strong>Speech Recognition</strong></li>
</ul>
<h4 class="n">Note: Among all of the above, Machine learning plays a crucial role in AI. Machine learning and deep learning are the ways of achieving AI in real life. </h4>
<img alt="Subsets of AI" src="https://static.javatpoint.com/tutorial/ai/images/subsets-of-ai.png"/>
<h2 class="h2">Machine Learning</h2>
<p>Machine learning is a part of AI which provides intelligence to machines with the ability to automatically learn with experiences without being explicitly programmed. </p>
<ul class="points">
<li>It is primarily concerned with the design and development of algorithms that allow the system to learn from historical data.</li>
<li>Machine Learning is based on the idea that machines can learn from past data, identify patterns, and make decisions using algorithms.</li>
<li>Machine learning algorithms are designed in such a way that they can learn and improve their performance automatically. </li>
<li>Machine learning helps in discovering patterns in data. </li>
</ul>
<h3 class="h3">Types of Machine Learning</h3>
<img alt="Subsets of AI" src="https://static.javatpoint.com/tutorial/ai/images/types-of-machine-learning.png"/>
<p>Machine learning can be subdivided intothe main three types:</p>
<ul class="points">
<li><strong>Supervised learning:</strong><br/>
Supervised learning is a type of machine learning in which machine learn from known datasets (set of training examples), and then predict the output. A supervised learning agent needs to find out the function that matches a given sample set.<br/>
Supervised learning further can be classified into two categories of algorithms:
<ol class="pointsa">
<li><strong>Classifications</strong></li>
<li><strong>Regression</strong></li>
</ol></li>
<li><strong>Reinforcement learning:</strong><br/>
Reinforcement learning is a type of learning in which an AI agent is trained by giving some commands, and on each action, an agent gets a reward as a feedback.Using these feedbacks, agent improves its performance. <br/>
Reward feedback can be positive or negative which means on each good action, agent receives a positive reward while for wrong action, it gets a negative reward.<br/>
Reinforcement learning is of two types:
<ol class="pointsa">
<li><strong>Positive Reinforcement learning</strong></li>
<li><strong>Negative Reinforcement learning</strong></li>
</ol></li>
<li><strong>Unsupervised learning:</strong><br/>
Unsupervised learning is associated with learning without supervision or training. In unsupervised learning, the algorithms are trained with data which is neither labeled nor classified. In unsupervised learning, the agent needs to learn from patterns without corresponding output values.<br/>
Unsupervised learning can be classified into two categories of algorithms:
<ol class="pointsa">
<li><strong>Clustering</strong></li>
<li><strong>Association</strong></li>
</ol></li>
</ul>
<h2 class="h2">Natural Language processing</h2>
<p>Natural language processing is a subfield of computer science and artificial intelligence. NLP enables a computer system to understand and process human language such as English.</p>
<p>NLP plays an important role in AI as without NLP, AI agent cannot work on human instructions, but with the help of NLP, we can instruct an AI system on our language. Today we are all around AI, and as well as NLP, we can easily ask Siri, Google or Cortana to help us in our language.</p>
<p>Natural language processing application enables a user to communicate with the system in their own words directly.</p>
<p>The Input and output of NLP applications can be in two forms:</p>
<ul class="points">
<li><strong>Speech</strong></li>
<li><strong>Text</strong></li>
</ul>
<h2 class="h2">Deep Learning</h2>
<p>Deep learning is a subset of machine learning which provides the ability to machine to perform human-like tasks without human involvement. It provides the ability to an AI agent to mimic the human brain. Deep learning can use both supervised and unsupervised learning to train an AI agent. </p>
<ul class="points">
<li>Deep learning is implemented through neural networks architecture hence also called a <strong>deep neural network</strong>.</li>
<li>Deep learning is the primary technology behind self-driving cars, speech recognition, image recognition, automatic machine translation, etc.</li>
<li>The main challenge for deep learning is that it requires lots of data with lots of computational power. </li>
</ul>
<h3 class="h3">How deep learning works:</h3>
<ul class="points">
<li><strong>Deep Learning Algorithms work on deep neural networks, so it is called deep learning. These deep neural networks are made of multiple layers.</strong></li>
<li><strong>The first layer is called an Input layer, the last layer is called an output layer, and all layers between these two layers are called hidden layers.</strong></li>
<li><strong>In the deep neural network, there are multiple hidden layers, and each layer is composed of neurons. These neurons are connected in each layer.</strong></li>
<li><strong>The input layer receives input data, and the neurons propagate the input signal to its above layers. </strong></li>
<li><strong>The hidden layers perform mathematical operations on inputs, and the performed data forwarded to the output layer.</strong></li>
<li><strong>The output layer returns the output to the user.</strong></li>
</ul>
<img alt="Subsets of AI" src="https://static.javatpoint.com/tutorial/ai/images/deep-learning-works.png"/>
<h2 class="h2">Expert Systems</h2>
<ul class="points">
<li><strong>An expert system is an application of artificial intelligence. In artificial intelligence, expert systems are the computer programs that rely on obtaining the knowledge of human experts and programming that knowledge into a system.</strong></li>
<li><strong>Expert systems emulate the decision-making ability of human experts. These systems are designed to solve the complex problem through bodies of knowledge rather than conventional procedural code.</strong></li>
<li><strong>One of the examples of an expert system is a Suggestion for the spelling error while typing in the Google search box.</strong></li>
<li><strong>Following are some characteristics of expert systems:</strong>
<ul class="points">
<li><strong>High performance</strong></li>
<li><strong>Reliable</strong></li>
<li><strong>Highly responsive</strong></li>
<li><strong>Understandable</strong></li>
</ul></li>
</ul>
<h2 class="h2">Robotics</h2>
<ul class="points">
<li>Robotics is a branch of artificial intelligence and engineering which is used for designing and manufacturing of robots.</li>
<li>Robots are the programmed machines which can perform a series of actions automatically or semi-automatically.</li>
<li>AI can be applied to robots to make intelligent robots which can perform the task with their intelligence. AI algorithms are necessary to allow a robot to perform more complex tasks.</li>
<li>Nowadays, AI and machine learning are being applied on robots to manufacture intelligent robots which can also interact socially like humans. One of the best examples of AI in robotics is <u>Sophia robot</u>.</li>
</ul>
<h2 class="h2">Machine Vision</h2>
<ul class="points">
<li>Machine vision is an application of computer vision which enables a machine to recognize the object.</li>
<li>Machine vision captures and analyses visual information using one or more video cameras, analog-to-digital conversations, and digital signal processing.</li>
<li>Machine vision systems are programmed to perform narrowly defined tasks such as counting objects, reading the serial number, etc.</li>
<li>Computer systems do not see in the same way as human eyes can see, but it is also not bounded by human limitations such as to see through the wall.</li>
<li>With the help of machine learning and machine vision, an AI agent can be able to see through walls.</li>
</ul>
<h2 class="h2">Speech Recognition:</h2>
<p>Speech recognition is a technology which enables a machine to understand the spoken language and translate into a machine-readable format. It can also be said as automatic Speech recognition and computer speech recognition. <strong>It is a way to talk with a computer, and on the basis of that command, a computer can perform a specific task</strong>.</p>
<p>There is some speech recognition software which has a limited vocabulary of words and phrase. This software requires unambiguous spoken language to understand and perform specific task. Today's there are various software or devices which contains speech recognition technology such as Cortana, Google virtual assistant, Apple Siri, etc.</p>
<p>We need to train our speech recognition system to understand our language. In previous days, these systems were only designed to convert the speech to text, but now there are various devices which can directly convert speech into commands.</p>
<p>Speech recognition systems can be used in the following areas:</p>
<ul class="points">
<li><strong>System control or navigation system</strong></li>
<li><strong>Industrial application</strong></li>
<li><strong>Voice dialing system</strong></li>
</ul>
<p>There are two types of speech recognition</p>
<ol class="points">
<li><strong>Speaker Dependent</strong></li>
<li><strong>Speaker Independent</strong></li>
</ol>
<h4 class="n">Note: You will study the above topics in detail in later chapters. </h4>
<h1 class="h1">Machine Learning Tutorial</h1>
<img alt="Machine Learning Tutorial" class="imageright" src="https://static.javatpoint.com/tutorial/machine-learning/images/machine-learning-logo.png"/>
<p>Machine Learning tutorial provides basic and advanced concepts of machine learning. Our machine learning tutorial is designed for students and working professionals.</p>
<p>Machine learning is a growing technology which enables computers to learn automatically from past data. Machine learning uses various algorithms for <strong>building mathematical models and making predictions using historical data or information</strong>. Currently, it is being used for various tasks such as <strong>image recognition</strong>, <strong>speech recognition</strong>, <strong>email filtering</strong>, <strong>Facebook auto-tagging</strong>, <strong>recommender system</strong>, and many more.</p>
<p>This machine learning tutorial gives you an introduction to machine learning along with the wide range of machine learning techniques such as <strong>Supervised</strong>, <strong>Unsupervised</strong>, and <strong>Reinforcement</strong> learning. You will learn about regression and classification models, clustering methods, hidden Markov models, and various sequential models.</p>
<h2 class="h2">Prerequisites</h2>
<p>Before learning machine learning, you must have the basic knowledge of followings so that you can easily understand the concepts of machine learning:</p>
<ul class="points">
<li>Fundamental knowledge of probability and linear algebra. </li>
<li>The ability to code in any computer language, especially in Python language.</li>
<li>Knowledge of Calculus, especially derivatives of single variable and multivariate functions. </li>
</ul>
<h2 class="h2">Audience</h2>
<p>Our Machine learning tutorial is designed to help beginner and professionals. </p>
<h2 class="h2">Problems</h2>
<p>We assure you that you will not find any difficulty while learning our Machine learning tutorial. But if there is any mistake in this tutorial, kindly post the problem or error in the contact form so that we can improve it. </p>
<h1 class="h1">NLP Tutorial</h1>
<p>NLP tutorial provides basic and advanced concepts of the NLP tutorial. Our NLP tutorial is designed for beginners and professionals.</p>
<ul class="points">
<li><a href="#What">What is NLP?</a></li>
<li><a href="#History">History of NLP</a></li>
<li><a href="#Advantages">Advantages of NLP</a></li>
<li><a href="#Disadvantages">Disadvantages of NLP</a></li>
<li><a href="#Components">Components of NLP</a></li>
<li><a href="#Applications">Applications of NLP</a></li>
<li><a href="#How">How does NLP work?</a></li>
<li><a href="#Phases">Phases of NLP</a></li>
<li><a href="#Why">Why NLP is Difficult?</a></li>
<li><a href="#APIs">NLP APIs</a></li>
<li><a href="#Libraries">NLP Libraries</a></li>
<li><a href="#Difference">Difference between Natural language and Computer language</a></li>
</ul>
<h1 class="h1">TensorFlow Tutorial</h1>
<img alt="TensorFlow Tutorial" class="imageright" src="https://static.javatpoint.com/tutorial/tensorflow/images/tensorflow-tutorial.png"/>
<p>TensorFlow tutorial is designed for both beginners and professionals. Our tutorial provides all the basic and advanced concept of machine learning and deep learning concept such as deep neural network, image processing and sentiment analysis.</p>
<p>TensorFlow is one of the famous deep learning framework, developed by <strong>Google</strong> Team. It is a free and open source software library and designed in <strong>Python</strong> programming language, this tutorial is designed in such a way that we can easily implement deep learning project on TensorFlow in an easy and efficient way.</p>
<h2 class="h2">Prerequisite</h2>
<p>TensorFlow is completely based on Python. So, it is essential to have basic knowledge of Python. Good understanding of basic mathematics and artificial intelligence concept is allow us to understand TensorFlow easily.</p>
<h2 class="h2">Audience</h2>
<p>This tutorial is helpful for the students who are interested in python and focused on research and development with many machine learning and deep learning algorithms. The aim of the tutorial is to describe all TensorFlow objects and methods.</p>
<h2 class="h2">Problems</h2>
<p>We assure that we will not find any problem with this TensorFlow tutorial. But if there is any mistake, please post the problem in the contact form.</p>
<h1 class="h1">PyTorch Tutorial</h1>
<img alt="PyTorch" src="https://static.javatpoint.com/tutorial/pytorch/images/pytorch.png" style="float:right;margin-left:10px"/>
<p>PyTorch Tutorial is designed for both beginners and professionals. Our Tutorial provides all the basic and advanced concepts of Deep learning, such as deep neural network and image processing.</p>
<p>PyTorch is a framework of deep learning, and it is a Python machine learning package based on Torch. This tutorial is designed in such a way that we can easily implement deep learning project on PyTorch in a very efficient way.</p>
<h2 class="h2">Prerequisite</h2>
<p>PyTorch is completely based on Python. So, it is essential to have basic knowledge of Python to implement the PyTorch project. Good understanding of basic mathematics allows us to understand the concept of PyTorch better.  </p>
<h2 class="h2">Audience</h2>
<p>This tutorial is helpful for those students who are interested in gaining the knowledge of how deep learning projects are implemented on PyTorch framework. This tutorial covers all the basics of PyTorch and how deep neural networks are implemented and use in the development of deep learning project.</p>
<h2 class="h2">Problems</h2>
<p>We assure that you will not find any problem with this PyTorch Tutorial. But if there is any mistake, please post the problem in the contact form.</p>
<h1 class="h1">Data Science Tutorial for Beginners</h1>
<p>Data Science has become the most demanding job of the 21st century. Every organization is looking for candidates with knowledge of data science. In this tutorial, we are giving an introduction to data science, with data science Job roles, tools for data science, components of data science, application, etc.</p>
<p>So let's start,</p>
<img alt="Data Science tutorial" src="https://static.javatpoint.com/tutorial/data-science/images/data-science.png"/>

</body>
</html>